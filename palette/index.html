<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A library that makes linear color calculations and conversion easy and accessible for anyone. It uses the type system to enforce correctness and to avoid mistakes, such as mixing incompatible color types."><meta name="keywords" content="rust, rustlang, rust-lang, palette"><title>palette - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-93196c7a1c3542a8.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../static.files/light-4743e13df3dfe8c4.css"><link rel="stylesheet" disabled href="../static.files/dark-0e1b889528bd466b.css"><link rel="stylesheet" disabled href="../static.files/ayu-65289d5d067c7c66.css"><script id="default-settings" ></script><script src="../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-3367e395607fafc1.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../palette/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../palette/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate palette</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.7.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li><li><a href="#derives">Derive Macros</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">palette</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/palette/lib.rs.html#1-1536">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A library that makes linear color calculations and conversion easy and
accessible for anyone. It uses the type system to enforce correctness and to
avoid mistakes, such as mixing incompatible color types.</p>
<h2 id="type-safety-for-colors"><a href="#type-safety-for-colors">Type Safety for Colors</a></h2>
<p>Digital colors are not “just RGB”, and not even RGB is “just RGB”. There are
multiple representations of color, with a variety of pros and cons, and
multiple standards for how to encode and decode them. Palette represents
these “color spaces” as separate types for increased expressiveness and to
prevent mistakes.</p>
<p>Taking RGB as an example, it’s often stored or displayed as “gamma
corrected” values, meaning that a non-linear function has been applied to
its values. This encoding is not suitable for all kinds of calculations
(such as rescaling) and will give visibly incorrect results. Functions that
require linear RGB can therefore request, for example, <a href="rgb/type.LinSrgb.html" title="LinSrgb"><code>LinSrgb</code></a> as their
input type.</p>

<div class="example-wrap compile_fail"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="comment">// Srgb is an alias for Rgb&lt;Srgb, T&gt;, which is what most pictures store.
// LinSrgb is an alias for Rgb&lt;Linear&lt;Srgb&gt;, T&gt;, better for color manipulation.
</span><span class="kw">use </span>palette::{Srgb, LinSrgb};

<span class="kw">fn </span>do_something(a: LinSrgb, b: LinSrgb) -&gt; LinSrgb {
<span class="comment">// ...
</span>}

<span class="kw">let </span>orangeish = Srgb::new(<span class="number">1.0</span>, <span class="number">0.6</span>, <span class="number">0.0</span>);
<span class="kw">let </span>blueish = Srgb::new(<span class="number">0.0</span>, <span class="number">0.2</span>, <span class="number">1.0</span>);
<span class="kw">let </span>result = do_something(orangeish, blueish); <span class="comment">// Does not compile</span></code></pre></div>
<p>The colors will have to be decoded before being used in the function:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Srgb is an alias for Rgb&lt;Srgb, T&gt;, which is what most pictures store.
// LinSrgb is an alias for Rgb&lt;Linear&lt;Srgb&gt;, T&gt;, better for color manipulation.
</span><span class="kw">use </span>palette::{Srgb, LinSrgb};

<span class="kw">fn </span>do_something(a: LinSrgb, b: LinSrgb) -&gt; LinSrgb {
<span class="comment">// ...
</span>}

<span class="kw">let </span>orangeish = Srgb::new(<span class="number">1.0</span>, <span class="number">0.6</span>, <span class="number">0.0</span>).into_linear();
<span class="kw">let </span>blueish = Srgb::new(<span class="number">0.0</span>, <span class="number">0.2</span>, <span class="number">1.0</span>).into_linear();
<span class="kw">let </span>result = do_something(orangeish, blueish);</code></pre></div>
<p>See the <a href="rgb/index.html" title="rgb">rgb</a> module for a deeper dive into RGB and (non-)linearity.</p>
<h2 id="color-spaces-and-conversion"><a href="#color-spaces-and-conversion">Color Spaces and Conversion</a></h2>
<p>As the previous section mentions, there are many different ways of
representing colors. These “color spaces” are represented as different types
in Palette, each with a description of what it is and how it works. Most of
them also have two type parameters for customization:</p>
<ul>
<li>The component type (<code>T</code>) that decides which number type is used. The
default is <code>f32</code>, but <code>u8</code>, <code>f64</code>, and any other type that implement the
required traits will work. Including SIMD types in many cases.</li>
<li>The reference white point (<code>W</code>) or standard (<code>S</code>) that affects the range,
encoding or display properties of the color. This varies between color
spaces and can usually be left as its default or be set via a type alias.
For example, the <a href="rgb/type.Srgb.html" title="Srgb"><code>Srgb</code></a> and <a href="rgb/type.LinSrgb.html" title="LinSrgb"><code>LinSrgb</code></a> type aliases are both variants
of the <a href="rgb/struct.Rgb.html" title="rgb::Rgb"><code>Rgb</code></a> type, but with different standard (<code>S</code>) types.</li>
</ul>
<p>Selecting the proper color space can have a big impact on how the resulting
image looks (as illustrated by some of the programs in <code>examples</code>), and
Palette makes the conversion between them as easy as a call to
<a href="convert/trait.FromColor.html#tymethod.from_color" title="FromColor::from_color"><code>from_color</code></a> or
<a href="convert/trait.IntoColor.html#tymethod.into_color" title="IntoColor::into_color"><code>into_color</code></a>.</p>
<p>This example takes an sRGB color, converts it to CIE L*C*h°, a color space
similar to the colloquial HSL/HSV color spaces, shifts its hue by 180° and
converts it back to RGB:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>palette::{FromColor, ShiftHue, IntoColor, Lch, Srgb};

<span class="kw">let </span>lch_color: Lch = Srgb::new(<span class="number">0.8</span>, <span class="number">0.2</span>, <span class="number">0.1</span>).into_color();
<span class="kw">let </span>new_color = Srgb::from_color(lch_color.shift_hue(<span class="number">180.0</span>));</code></pre></div>
<h2 id="transparency"><a href="#transparency">Transparency</a></h2>
<p>There are many cases where pixel transparency is important, but there are
also many cases where it would just be unused memory space. Palette has
therefore adopted a structure where the transparency component (alpha) is
attachable using the <a href="struct.Alpha.html"><code>Alpha</code></a> type. This approach has shown
to be very modular and easy to maintain, compared to having transparent
copies of each type.</p>
<p>An additional benefit is allowing operations to selectively affect the alpha
component:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Each color type has a transparent alias that ends with &quot;a&quot; for &quot;alpha&quot;
</span><span class="kw">use </span>palette::{LinSrgb, LinSrgba};

<span class="kw">let </span><span class="kw-2">mut </span>c1 = LinSrgba::new(<span class="number">1.0</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.8</span>);
<span class="kw">let </span>c2 = LinSrgb::new(<span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);

c1.color = c1.color * c2; <span class="comment">//Leave the alpha as it is
</span>c1.blue += <span class="number">0.2</span>; <span class="comment">//The color components can easily be accessed
</span>c1 = c1 * <span class="number">0.5</span>; <span class="comment">//Scale both the color and the alpha</span></code></pre></div>
<p>There’s also <a href="blend/struct.PreAlpha.html" title="blend::PreAlpha"><code>PreAlpha</code></a> that represents pre-multiplied
alpha (also known as alpha masked colors). It’s commonly used in color
blending and composition.</p>
<h2 id="images-and-buffers"><a href="#images-and-buffers">Images and Buffers</a></h2>
<p>Oftentimes, pixel data is stored in a plain array or slice such as a <code>[u8; 3]</code>. The <a href="cast/index.html" title="cast"><code>cast</code></a> module allows for easy conversion between Palette colors
and arrays or slices. This also helps when working with other crates or
systems. Here’s an example of how the pixels in an image from the <code>image</code>
crate can be worked with as <code>Srgb&lt;u8&gt;</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>image::RgbImage;
<span class="kw">use </span>palette::{Srgb, Oklab, cast, Lighten, IntoColor, FromColor};

<span class="kw">fn </span>lighten(image: <span class="kw-2">&amp;mut </span>RgbImage, amount: f32) {
    <span class="comment">// RgbImage can be dereferenced as [u8], allowing us to cast it as a
    // component slice to sRGB with u8 components.
    </span><span class="kw">for </span>pixel <span class="kw">in </span>cast::from_component_slice_mut::&lt;Srgb&lt;u8&gt;&gt;(image) {
        <span class="comment">// Converting to linear sRGB with f32 components, and then to Oklab.
        </span><span class="kw">let </span>color: Oklab = pixel.into_linear::&lt;f32&gt;().into_color();

        <span class="kw">let </span>lightened_color = color.lighten(amount);

        <span class="comment">// Converting back to non-linear sRGB with u8 components.
        </span><span class="kw-2">*</span>pixel = Srgb::from_linear(lightened_color.into_color());
    }
}</code></pre></div>
<p>Some of the conversions are also implemented on the color types as <code>From</code>,
<code>TryFrom</code>, <code>Into</code>, <code>TryFrom</code> and <code>AsRef</code>. This example shows how <code>from</code> can
be used to convert a <code>[u8;3]</code> into a Palette color, <code>into_format</code> converts
from  <code>Srgb&lt;u8&gt;</code> to <code>Srgb&lt;f32&gt;</code>, and finally <code>into</code> converts back from a
Palette color back to a <code>[u8;3]</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>approx::assert_relative_eq;
<span class="kw">use </span>palette::Srgb;

<span class="kw">let </span>buffer = [<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>];
<span class="kw">let </span>srgb = Srgb::from(buffer);
<span class="macro">assert_eq!</span>(srgb, Srgb::&lt;u8&gt;::new(<span class="number">255u8</span>, <span class="number">0</span>, <span class="number">255</span>));

<span class="kw">let </span>srgb_float: Srgb&lt;f32&gt; = srgb.into_format();
<span class="macro">assert_relative_eq!</span>(srgb_float, Srgb::new(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>));

<span class="kw">let </span>array: [u8; <span class="number">3</span>] = srgb_float.into_format().into();
<span class="macro">assert_eq!</span>(array, buffer);</code></pre></div>
<h2 id="a-basic-workflow"><a href="#a-basic-workflow">A Basic Workflow</a></h2>
<p>The overall workflow can be divided into three steps, where the first and
last may be taken care of by other parts of the application:</p>
<div class="example-wrap"><pre class="language-text"><code>Decoding -&gt; Processing -&gt; Encoding
</code></pre></div><h3 id="1-decoding"><a href="#1-decoding">1. Decoding</a></h3>
<p>Find out what the source format is and convert it to a linear color space.
There may be a specification, such as when working with SVG or CSS.</p>
<p>When working with RGB or gray scale (luma):</p>
<ul>
<li>
<p>If you are asking your user to enter an RGB value, you are in a gray zone
where it depends on the context. It’s usually safe to assume sRGB, but
sometimes it’s already linear.</p>
</li>
<li>
<p>If you are decoding an image, there may be some meta data that gives you
the necessary details. Otherwise it’s most commonly sRGB. Usually you will
end up with a slice or vector with RGB bytes, which can easily be converted
to Palette colors:</p>
</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>palette::{Srgb, cast};

<span class="comment">// This works for any color type (even non-RGB) that can have the
// buffer element type as component.
</span><span class="kw">let </span>color_buffer: <span class="kw-2">&amp;mut </span>[Srgb&lt;u8&gt;] = cast::from_component_slice_mut(<span class="kw-2">&amp;mut </span>image_buffer);</code></pre></div>
<ul>
<li>If you are getting your colors from the GPU, in a game or other graphical
application, or if they are otherwise generated by the application, then
chances are that they are already linear. Still, make sure to check that
they are not being encoded somewhere.</li>
</ul>
<p>When working with other colors:</p>
<ul>
<li>
<p>For HSL, HSV, HWB: Check if they are based on any other color space than
sRGB, such as Adobe or Apple RGB.</p>
</li>
<li>
<p>For any of the CIE color spaces, check for a specification of white point
and light source. These are necessary for converting to RGB and other
colors, that depend on perception and “viewing devices”. Common defaults are
the D65 light source and the sRGB white point. The Palette defaults should
take you far.</p>
</li>
</ul>
<h3 id="2-processing"><a href="#2-processing">2. Processing</a></h3>
<p>When your color has been decoded into some Palette type, it’s ready for
processing. This includes things like blending, hue shifting, darkening and
conversion to other formats. Just make sure that your non-linear RGB is made
linear first (<code>my_srgb.into_linear()</code>), to make the operations available.</p>
<p>Different color spaced have different capabilities, pros and cons. You may
have to experiment a bit (or look at the example programs) to find out what
gives the desired result.</p>
<h3 id="3-encoding"><a href="#3-encoding">3. Encoding</a></h3>
<p>When the desired processing is done, it’s time to encode the colors back
into some image format. The same rules applies as for the decoding, but the
process reversed.</p>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2><div class="item-table"><div class="item-row"><div class="item-left import-item" id="reexport.WithAlpha"><code>pub use alpha::<a class="trait" href="trait.WithAlpha.html" title="trait palette::WithAlpha">WithAlpha</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.GammaLuma"><code>pub use luma::<a class="type" href="luma/type.GammaLuma.html" title="type palette::luma::GammaLuma">GammaLuma</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.GammaLumaa"><code>pub use luma::<a class="type" href="luma/type.GammaLumaa.html" title="type palette::luma::GammaLumaa">GammaLumaa</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.LinLuma"><code>pub use luma::<a class="type" href="luma/type.LinLuma.html" title="type palette::luma::LinLuma">LinLuma</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.LinLumaa"><code>pub use luma::<a class="type" href="luma/type.LinLumaa.html" title="type palette::luma::LinLumaa">LinLumaa</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.SrgbLuma"><code>pub use luma::<a class="type" href="luma/type.SrgbLuma.html" title="type palette::luma::SrgbLuma">SrgbLuma</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.SrgbLumaa"><code>pub use luma::<a class="type" href="luma/type.SrgbLumaa.html" title="type palette::luma::SrgbLumaa">SrgbLumaa</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.GammaSrgb"><code>pub use rgb::<a class="type" href="rgb/type.GammaSrgb.html" title="type palette::rgb::GammaSrgb">GammaSrgb</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.GammaSrgba"><code>pub use rgb::<a class="type" href="rgb/type.GammaSrgba.html" title="type palette::rgb::GammaSrgba">GammaSrgba</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.LinSrgb"><code>pub use rgb::<a class="type" href="rgb/type.LinSrgb.html" title="type palette::rgb::LinSrgb">LinSrgb</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.LinSrgba"><code>pub use rgb::<a class="type" href="rgb/type.LinSrgba.html" title="type palette::rgb::LinSrgba">LinSrgba</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.Srgb"><code>pub use rgb::<a class="type" href="rgb/type.Srgb.html" title="type palette::rgb::Srgb">Srgb</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.Srgba"><code>pub use rgb::<a class="type" href="rgb/type.Srgba.html" title="type palette::rgb::Srgba">Srgba</a>;</code></div></div></div><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="angle/index.html" title="palette::angle mod">angle</a></div><div class="item-right docblock-short">Traits for working with angular values, such as for in hues.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="blend/index.html" title="palette::blend mod">blend</a></div><div class="item-right docblock-short">Color blending and blending equations.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="bool_mask/index.html" title="palette::bool_mask mod">bool_mask</a></div><div class="item-right docblock-short">Traits for abstracting over Boolean types.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="cast/index.html" title="palette::cast mod">cast</a></div><div class="item-right docblock-short">Traits and functions for casting colors to and from other data types.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="chromatic_adaptation/index.html" title="palette::chromatic_adaptation mod">chromatic_adaptation</a></div><div class="item-right docblock-short">Convert colors from one reference white point to another</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="convert/index.html" title="palette::convert mod">convert</a></div><div class="item-right docblock-short">Traits for converting between color spaces.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="encoding/index.html" title="palette::encoding mod">encoding</a></div><div class="item-right docblock-short">Number and color encoding traits, types and standards.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="luma/index.html" title="palette::luma mod">luma</a></div><div class="item-right docblock-short">Luminance types.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="named/index.html" title="palette::named mod">named</a></div><div class="item-right docblock-short">A collection of named color constants. Can be toggled with the <code>&quot;named&quot;</code> and
<code>&quot;named_from_str&quot;</code> Cargo features.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="num/index.html" title="palette::num mod">num</a></div><div class="item-right docblock-short">Traits for abstracting over numeric types.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="rgb/index.html" title="palette::rgb mod">rgb</a></div><div class="item-right docblock-short">RGB types, spaces and standards.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="stimulus/index.html" title="palette::stimulus mod">stimulus</a></div><div class="item-right docblock-short">Traits for working with stimulus colors and values, such as RGB and XYZ.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="white_point/index.html" title="palette::white_point mod">white_point</a></div><div class="item-right docblock-short">Defines the tristimulus values of the CIE Illuminants.</div></div></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Alpha.html" title="palette::Alpha struct">Alpha</a></div><div class="item-right docblock-short">An alpha component wrapper for colors.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.FromColorMutGuard.html" title="palette::FromColorMutGuard struct">FromColorMutGuard</a></div><div class="item-right docblock-short">A scope guard that restores the guarded colors to their original type when
dropped.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Hsl.html" title="palette::Hsl struct">Hsl</a></div><div class="item-right docblock-short">HSL color space.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Hsluv.html" title="palette::Hsluv struct">Hsluv</a></div><div class="item-right docblock-short">HSLuv color space.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Hsv.html" title="palette::Hsv struct">Hsv</a></div><div class="item-right docblock-short">HSV color space.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Hwb.html" title="palette::Hwb struct">Hwb</a></div><div class="item-right docblock-short">HWB color space.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Lab.html" title="palette::Lab struct">Lab</a></div><div class="item-right docblock-short">The CIE L*a*b* (CIELAB) color space.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.LabHue.html" title="palette::LabHue struct">LabHue</a></div><div class="item-right docblock-short">A hue type for the CIE L*a*b* family of color spaces.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Lch.html" title="palette::Lch struct">Lch</a></div><div class="item-right docblock-short">CIE L*C*h°, a polar version of <a href="struct.Lab.html">CIE L*a*b*</a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Lchuv.html" title="palette::Lchuv struct">Lchuv</a></div><div class="item-right docblock-short">CIE L*C*uv h°uv, a polar version of <a href="struct.Luv.html">CIE L*u*v*</a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Luv.html" title="palette::Luv struct">Luv</a></div><div class="item-right docblock-short">The CIE L*u*v* (CIELUV) color space.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.LuvHue.html" title="palette::LuvHue struct">LuvHue</a></div><div class="item-right docblock-short">A hue type for the CIE L*u*v* family of color spaces.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Okhsl.html" title="palette::Okhsl struct">Okhsl</a></div><div class="item-right docblock-short">A Hue/Saturation/Lightness representation of <a href="struct.Oklab.html" title="Oklab"><code>Oklab</code></a> in the <code>sRGB</code> color space.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Okhsv.html" title="palette::Okhsv struct">Okhsv</a></div><div class="item-right docblock-short">A Hue/Saturation/Value representation of <a href="struct.Oklab.html" title="Oklab"><code>Oklab</code></a> in the <code>sRGB</code> color space.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Okhwb.html" title="palette::Okhwb struct">Okhwb</a></div><div class="item-right docblock-short">A Hue/Whiteness/Blackness representation of <a href="struct.Oklab.html" title="crate::Oklab"><code>Oklab</code></a> in the
<code>sRGB</code> color space, similar to <a href="struct.Okhwb.html" title="crate::Okhwb"><code>Hwb</code></a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Oklab.html" title="palette::Oklab struct">Oklab</a></div><div class="item-right docblock-short">The <a href="https://bottosson.github.io/posts/oklab/">Oklab color space</a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.OklabHue.html" title="palette::OklabHue struct">OklabHue</a></div><div class="item-right docblock-short">A hue type for the Oklab color space.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Oklch.html" title="palette::Oklch struct">Oklch</a></div><div class="item-right docblock-short">Oklch, a polar version of <a href="struct.Oklab.html">Oklab</a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.RgbHue.html" title="palette::RgbHue struct">RgbHue</a></div><div class="item-right docblock-short">A hue type for the RGB family of color spaces.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Xyz.html" title="palette::Xyz struct">Xyz</a></div><div class="item-right docblock-short">The CIE 1931 XYZ color space.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Yxy.html" title="palette::Yxy struct">Yxy</a></div><div class="item-right docblock-short">The CIE 1931 Yxy (xyY)  color space.</div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.ArrayExt.html" title="palette::ArrayExt trait">ArrayExt</a></div><div class="item-right docblock-short">Extension trait for fixed size arrays.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Clamp.html" title="palette::Clamp trait">Clamp</a></div><div class="item-right docblock-short">An operator for restricting a color’s components to their expected ranges.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.ClampAssign.html" title="palette::ClampAssign trait">ClampAssign</a></div><div class="item-right docblock-short">An assigning operator for restricting a color’s components to their expected
ranges.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.ColorDifference.html" title="palette::ColorDifference trait">ColorDifference</a></div><div class="item-right docblock-short">A trait for calculating the color difference between two colors.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Darken.html" title="palette::Darken trait">Darken</a></div><div class="item-right docblock-short">Operators for darkening a color;</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.DarkenAssign.html" title="palette::DarkenAssign trait">DarkenAssign</a></div><div class="item-right docblock-short">Assigning operators for darkening a color;</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Desaturate.html" title="palette::Desaturate trait">Desaturate</a></div><div class="item-right docblock-short">Operator for decreasing the saturation (or chroma) of a color.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.DesaturateAssign.html" title="palette::DesaturateAssign trait">DesaturateAssign</a></div><div class="item-right docblock-short">Assigning operator for decreasing the saturation (or chroma) of a color.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.FromColor.html" title="palette::FromColor trait">FromColor</a></div><div class="item-right docblock-short">A trait for converting one color from another, in a possibly lossy way.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.FromColorMut.html" title="palette::FromColorMut trait">FromColorMut</a></div><div class="item-right docblock-short">Temporarily convert colors in place.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.GetHue.html" title="palette::GetHue trait">GetHue</a></div><div class="item-right docblock-short">A trait for colors where a hue may be calculated.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.IntoColor.html" title="palette::IntoColor trait">IntoColor</a></div><div class="item-right docblock-short">A trait for converting a color into another, in a possibly lossy way.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.IntoColorMut.html" title="palette::IntoColorMut trait">IntoColorMut</a></div><div class="item-right docblock-short">Temporarily convert colors in place. The <code>Into</code> counterpart to
<a href="convert/trait.FromColorMut.html" title="FromColorMut"><code>FromColorMut</code></a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.IsWithinBounds.html" title="palette::IsWithinBounds trait">IsWithinBounds</a></div><div class="item-right docblock-short">Checks if color components are within their expected range bounds.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Lighten.html" title="palette::Lighten trait">Lighten</a></div><div class="item-right docblock-short">Operators for lightening a color.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.LightenAssign.html" title="palette::LightenAssign trait">LightenAssign</a></div><div class="item-right docblock-short">Assigning operators for lightening a color.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Mix.html" title="palette::Mix trait">Mix</a></div><div class="item-right docblock-short">Linear color interpolation of two colors.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.MixAssign.html" title="palette::MixAssign trait">MixAssign</a></div><div class="item-right docblock-short">Assigning linear color interpolation of two colors.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.NextArray.html" title="palette::NextArray trait">NextArray</a></div><div class="item-right docblock-short">Temporary helper trait for getting an array type of size <code>N + 1</code>.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.RelativeContrast.html" title="palette::RelativeContrast trait">RelativeContrast</a></div><div class="item-right docblock-short">A trait for calculating relative contrast between two colors.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Saturate.html" title="palette::Saturate trait">Saturate</a></div><div class="item-right docblock-short">Operator for increasing the saturation (or chroma) of a color.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.SaturateAssign.html" title="palette::SaturateAssign trait">SaturateAssign</a></div><div class="item-right docblock-short">Assigning operator for increasing the saturation (or chroma) of a color.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.SetHue.html" title="palette::SetHue trait">SetHue</a></div><div class="item-right docblock-short">Change the hue of a color to a specific value without moving.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.ShiftHue.html" title="palette::ShiftHue trait">ShiftHue</a></div><div class="item-right docblock-short">Operator for increasing or decreasing the hue by an amount.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.ShiftHueAssign.html" title="palette::ShiftHueAssign trait">ShiftHueAssign</a></div><div class="item-right docblock-short">Assigning operator for increasing or decreasing the hue by an amount.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.WithAlpha.html" title="palette::WithAlpha trait">WithAlpha</a></div><div class="item-right docblock-short">A trait for color types that can have or be given transparency (alpha channel).</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.WithHue.html" title="palette::WithHue trait">WithHue</a></div><div class="item-right docblock-short">Change the hue of a color to a specific value.</div></div></div><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.contrast_ratio.html" title="palette::contrast_ratio fn">contrast_ratio</a></div><div class="item-right docblock-short">Calculate the ratio between two <code>luma</code> values.</div></div></div><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="type" href="type.Hsla.html" title="palette::Hsla type">Hsla</a></div><div class="item-right docblock-short">Linear HSL with an alpha component. See the <a href="struct.Alpha.html#Hsla"><code>Hsla</code> implementation in
<code>Alpha</code></a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="type" href="type.Hsluva.html" title="palette::Hsluva type">Hsluva</a></div><div class="item-right docblock-short">HSLuv with an alpha component. See the <a href="struct.Alpha.html#Hsluva"><code>Hsluva</code> implementation in
<code>Alpha</code></a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="type" href="type.Hsva.html" title="palette::Hsva type">Hsva</a></div><div class="item-right docblock-short">Linear HSV with an alpha component. See the <a href="struct.Alpha.html#Hsva"><code>Hsva</code> implementation in
<code>Alpha</code></a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="type" href="type.Hwba.html" title="palette::Hwba type">Hwba</a></div><div class="item-right docblock-short">Linear HWB with an alpha component. See the <a href="struct.Alpha.html#Hwba"><code>Hwba</code> implementation in
<code>Alpha</code></a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="type" href="type.Laba.html" title="palette::Laba type">Laba</a></div><div class="item-right docblock-short">CIE L*a*b* (CIELAB) with an alpha component. See the <a href="struct.Alpha.html#Laba"><code>Laba</code>
implementation in <code>Alpha</code></a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="type" href="type.Lcha.html" title="palette::Lcha type">Lcha</a></div><div class="item-right docblock-short">CIE L*C*h° with an alpha component. See the <a href="struct.Alpha.html#Lcha"><code>Lcha</code> implementation in
<code>Alpha</code></a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="type" href="type.Lchuva.html" title="palette::Lchuva type">Lchuva</a></div><div class="item-right docblock-short">CIE L*C*uv h°uv with an alpha component. See the <a href="struct.Alpha.html#Lchuva"><code>Lchuva</code> implementation in
<code>Alpha</code></a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="type" href="type.Luva.html" title="palette::Luva type">Luva</a></div><div class="item-right docblock-short">CIE L*u*v* (CIELUV) with an alpha component. See the <a href="struct.Alpha.html#Luva"><code>Luva</code>
implementation in <code>Alpha</code></a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="type" href="type.Mat3.html" title="palette::Mat3 type">Mat3</a></div><div class="item-right docblock-short">A 9 element array representing a 3x3 matrix.</div></div><div class="item-row"><div class="item-left module-item"><a class="type" href="type.Okhsla.html" title="palette::Okhsla type">Okhsla</a></div><div class="item-right docblock-short">Okhsl with an alpha component.</div></div><div class="item-row"><div class="item-left module-item"><a class="type" href="type.Okhsva.html" title="palette::Okhsva type">Okhsva</a></div><div class="item-right docblock-short">Okhsv with an alpha component. See the <a href="struct.Alpha.html#Okhsva"><code>Okhsva</code> implementation in
<code>Alpha</code></a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="type" href="type.Okhwba.html" title="palette::Okhwba type">Okhwba</a></div><div class="item-right docblock-short">Okhwb with an alpha component. See the <a href="struct.Alpha.html#Okhwba"><code>Okhwba</code> implementation in
<code>Alpha</code></a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="type" href="type.Oklaba.html" title="palette::Oklaba type">Oklaba</a></div><div class="item-right docblock-short">Oklab with an alpha component.</div></div><div class="item-row"><div class="item-left module-item"><a class="type" href="type.Oklcha.html" title="palette::Oklcha type">Oklcha</a></div><div class="item-right docblock-short">Oklch with an alpha component. See the <a href="struct.Alpha.html#Oklcha"><code>Oklcha</code> implementation in
<code>Alpha</code></a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="type" href="type.Xyza.html" title="palette::Xyza type">Xyza</a></div><div class="item-right docblock-short">CIE 1931 XYZ with an alpha component. See the <a href="struct.Alpha.html#Xyza"><code>Xyza</code> implementation in
<code>Alpha</code></a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="type" href="type.Yxya.html" title="palette::Yxya type">Yxya</a></div><div class="item-right docblock-short">CIE 1931 Yxy (xyY) with an alpha component. See the <a href="struct.Alpha.html#Yxya"><code>Yxya</code> implementation
in <code>Alpha</code></a>.</div></div></div><h2 id="derives" class="small-section-header"><a href="#derives">Derive Macros</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="derive" href="derive.WithAlpha.html" title="palette::WithAlpha derive">WithAlpha</a></div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="palette" data-themes="" data-resource-suffix="" data-rustdoc-version="1.68.2 (9eb3afe9e 2023-03-27)" data-search-js="search-98d53477a794af0b.js" data-settings-js="settings-c3c521c753752a1a.js" data-settings-css="settings-08ddfdda51b8ee2e.css" ></div></body></html>