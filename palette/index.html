<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A library that makes linear color calculations and conversion easy and accessible for anyone. It uses the type system to enforce correctness and to avoid mistakes, such as mixing incompatible color types."><title>palette - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-5bc39a1768837dd0.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="palette" data-themes="" data-resource-suffix="" data-rustdoc-version="1.77.2 (25ef9e3d8 2024-04-09)" data-channel="1.77.2" data-search-js="search-dd67cee4cfa65049.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-4c98445ec4002617.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-48f368f3872407c8.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../palette/index.html">palette</a><span class="version">0.7.6</span></h2></div><div class="sidebar-elems"><ul class="block">
            <li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Aliases</a></li><li><a href="#derives">Derive Macros</a></li></ul></section></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../palette/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">palette</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/palette/lib.rs.html#1-1431">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A library that makes linear color calculations and conversion easy and
accessible for anyone. It uses the type system to enforce correctness and to
avoid mistakes, such as mixing incompatible color types.</p>
<h2 id="where-do-i-start"><a class="doc-anchor" href="#where-do-i-start">§</a>Where Do I Start?</h2>
<p>The sections below give an overview of how the types in this library work,
including color conversion. If you want to get your hands dirty, you’ll
probably want to start with <a href="type.Srgb.html" title="type palette::Srgb"><code>Srgb</code></a> or <a href="type.Srgba.html" title="type palette::Srgba"><code>Srgba</code></a>. They are aliases for the
more generic <a href="rgb/struct.Rgb.html" title="struct palette::rgb::Rgb"><code>Rgb</code></a> type and represent sRGB(A), the most common
RGB format in images and tools. Their documentation has more details and
examples.</p>
<p>The documentation for each module and type goes deeper into their concepts.
Here are a few you may want to read:</p>
<ul>
<li><a href="rgb/struct.Rgb.html" title="struct palette::rgb::Rgb"><code>Rgb</code></a> - For getting started with RGB values.</li>
<li><a href="alpha/struct.Alpha.html" title="struct palette::alpha::Alpha"><code>Alpha</code></a> - For more details on transparency.</li>
<li><a href="convert/index.html" title="mod palette::convert"><code>convert</code></a> - Describes the conversion traits and how to use and implement
them.</li>
<li><a href="cast/index.html" title="mod palette::cast"><code>cast</code></a> - Describes how to cast color types to and from other data
formats, such as arrays and unsigned integers.</li>
<li><a href="color_difference/index.html" title="mod palette::color_difference"><code>color_difference</code></a> - Describes different ways of measuring the
difference between colors.</li>
</ul>
<h2 id="type-safety-for-colors"><a class="doc-anchor" href="#type-safety-for-colors">§</a>Type Safety for Colors</h2>
<p>Digital colors are not “just RGB”, and not even RGB is “just RGB”. There are
multiple representations of color, with a variety of pros and cons, and
multiple standards for how to encode and decode them. Palette represents
these “color spaces” as separate types for increased expressiveness and to
prevent mistakes.</p>
<p>Taking RGB as an example, it’s often stored or displayed as “gamma
corrected” values, meaning that a non-linear function has been applied to
its values. This encoding is not suitable for all kinds of calculations
(such as rescaling) and will give visibly incorrect results. Functions that
require linear RGB can therefore request, for example, <a href="type.LinSrgb.html" title="type palette::LinSrgb"><code>LinSrgb</code></a> as their
input type.</p>

<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="comment">// Srgb is an alias for Rgb&lt;Srgb, T&gt;, which is what most pictures store.
// LinSrgb is an alias for Rgb&lt;Linear&lt;Srgb&gt;, T&gt;, better for color manipulation.
</span><span class="kw">use </span>palette::{Srgb, LinSrgb};

<span class="kw">fn </span>do_something(a: LinSrgb, b: LinSrgb) -&gt; LinSrgb {
<span class="comment">// ...
</span>}

<span class="kw">let </span>orangeish = Srgb::new(<span class="number">1.0</span>, <span class="number">0.6</span>, <span class="number">0.0</span>);
<span class="kw">let </span>blueish = Srgb::new(<span class="number">0.0</span>, <span class="number">0.2</span>, <span class="number">1.0</span>);
<span class="kw">let </span>result = do_something(orangeish, blueish); <span class="comment">// Does not compile</span></code></pre></div>
<p>The colors will have to be decoded before being used in the function:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Srgb is an alias for Rgb&lt;Srgb, T&gt;, which is what most pictures store.
// LinSrgb is an alias for Rgb&lt;Linear&lt;Srgb&gt;, T&gt;, better for color manipulation.
</span><span class="kw">use </span>palette::{Srgb, LinSrgb};

<span class="kw">fn </span>do_something(a: LinSrgb, b: LinSrgb) -&gt; LinSrgb {
<span class="comment">// ...
</span>}

<span class="kw">let </span>orangeish = Srgb::new(<span class="number">1.0</span>, <span class="number">0.6</span>, <span class="number">0.0</span>).into_linear();
<span class="kw">let </span>blueish = Srgb::new(<span class="number">0.0</span>, <span class="number">0.2</span>, <span class="number">1.0</span>).into_linear();
<span class="kw">let </span>result = do_something(orangeish, blueish);</code></pre></div>
<p>See the <a href="rgb/index.html" title="mod palette::rgb">rgb</a> module for a deeper dive into RGB and (non-)linearity.</p>
<h2 id="color-spaces-and-conversion"><a class="doc-anchor" href="#color-spaces-and-conversion">§</a>Color Spaces and Conversion</h2>
<p>As the previous section mentions, there are many different ways of
representing colors. These “color spaces” are represented as different types
in Palette, each with a description of what it is and how it works. Most of
them also have two type parameters for customization:</p>
<ul>
<li>The component type (<code>T</code>) that decides which number type is used. The
default is <code>f32</code>, but <code>u8</code>, <code>f64</code>, and any other type that implement the
required traits will work. Including SIMD types in many cases.</li>
<li>The reference white point (<code>W</code>) or standard (<code>S</code>) that affects the range,
encoding or display properties of the color. This varies between color
spaces and can usually be left as its default or be set via a type alias.
For example, the <a href="type.Srgb.html" title="type palette::Srgb"><code>Srgb</code></a> and <a href="type.LinSrgb.html" title="type palette::LinSrgb"><code>LinSrgb</code></a> type aliases are both variants
of the <a href="rgb/struct.Rgb.html" title="struct palette::rgb::Rgb"><code>Rgb</code></a> type, but with different standard (<code>S</code>) types.</li>
</ul>
<p>Selecting the proper color space can have a big impact on how the resulting
image looks (as illustrated by some of the programs in <code>examples</code>), and
Palette makes the conversion between them as easy as a call to
<a href="convert/trait.FromColor.html#tymethod.from_color" title="associated function palette::convert::FromColor::from_color"><code>from_color</code></a> or
<a href="convert/trait.IntoColor.html#tymethod.into_color" title="method palette::convert::IntoColor::into_color"><code>into_color</code></a>.</p>
<p>This example takes an sRGB color, converts it to CIE L*C*h°, a color space
similar to the colloquial HSL/HSV color spaces, shifts its hue by 180° and
converts it back to RGB:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>palette::{FromColor, ShiftHue, IntoColor, Lch, Srgb};

<span class="kw">let </span>lch_color: Lch = Srgb::new(<span class="number">0.8</span>, <span class="number">0.2</span>, <span class="number">0.1</span>).into_color();
<span class="kw">let </span>new_color = Srgb::from_color(lch_color.shift_hue(<span class="number">180.0</span>));</code></pre></div>
<h2 id="transparency"><a class="doc-anchor" href="#transparency">§</a>Transparency</h2>
<p>There are many cases where pixel transparency is important, but there are
also many cases where it would just be unused memory space. Palette has
therefore adopted a structure where the transparency component (alpha) is
attachable using the <a href="alpha/struct.Alpha.html" title="struct palette::alpha::Alpha"><code>Alpha</code></a> type. This approach has shown to be very
modular and easy to maintain, compared to having transparent copies of each
type.</p>
<p>An additional benefit is allowing operations to selectively affect the alpha
component:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Each color type has a transparent alias that ends with "a" for "alpha"
</span><span class="kw">use </span>palette::{LinSrgb, LinSrgba};

<span class="kw">let </span><span class="kw-2">mut </span>c1 = LinSrgba::new(<span class="number">1.0</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.8</span>);
<span class="kw">let </span>c2 = LinSrgb::new(<span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);

c1.color = c1.color * c2; <span class="comment">//Leave the alpha as it is
</span>c1.blue += <span class="number">0.2</span>; <span class="comment">//The color components can easily be accessed
</span>c1 = c1 * <span class="number">0.5</span>; <span class="comment">//Scale both the color and the alpha</span></code></pre></div>
<p>There’s also <a href="blend/struct.PreAlpha.html" title="struct palette::blend::PreAlpha"><code>PreAlpha</code></a> that represents pre-multiplied
alpha (also known as alpha masked colors). It’s commonly used in color
blending and composition.</p>
<h2 id="images-and-buffers"><a class="doc-anchor" href="#images-and-buffers">§</a>Images and Buffers</h2>
<p>Oftentimes, pixel data is stored in a plain array or slice such as a <code>[u8; 3]</code>. The <a href="cast/index.html" title="mod palette::cast"><code>cast</code></a> module allows for easy conversion between Palette colors
and arrays or slices. This also helps when working with other crates or
systems. Here’s an example of how the pixels in an image from the <code>image</code>
crate can be worked with as <code>Srgb&lt;u8&gt;</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>image::RgbImage;
<span class="kw">use </span>palette::{Srgb, Oklab, cast::FromComponents, Lighten, IntoColor, FromColor};

<span class="kw">fn </span>lighten(image: <span class="kw-2">&amp;mut </span>RgbImage, amount: f32) {
    <span class="comment">// RgbImage can be dereferenced as [u8], allowing us to cast it as a
    // component slice to sRGB with u8 components.
    </span><span class="kw">for </span>pixel <span class="kw">in </span>&lt;<span class="kw-2">&amp;mut </span>[Srgb&lt;u8&gt;]&gt;::from_components(<span class="kw-2">&amp;mut **</span>image) {
        <span class="comment">// Converting to linear sRGB with f32 components, and then to Oklab.
        </span><span class="kw">let </span>color: Oklab = pixel.into_linear::&lt;f32&gt;().into_color();

        <span class="kw">let </span>lightened_color = color.lighten(amount);

        <span class="comment">// Converting back to non-linear sRGB with u8 components.
        </span><span class="kw-2">*</span>pixel = Srgb::from_linear(lightened_color.into_color());
    }
}</code></pre></div>
<p>Some of the conversions are also implemented on the color types as <code>From</code>,
<code>TryFrom</code>, <code>Into</code>, <code>TryFrom</code> and <code>AsRef</code>. This example shows how <code>from</code> can
be used to convert a <code>[u8;3]</code> into a Palette color, <code>into_format</code> converts
from  <code>Srgb&lt;u8&gt;</code> to <code>Srgb&lt;f32&gt;</code>, and finally <code>into</code> converts back from a
Palette color back to a <code>[u8;3]</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>approx::assert_relative_eq;
<span class="kw">use </span>palette::Srgb;

<span class="kw">let </span>buffer = [<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>];
<span class="kw">let </span>srgb = Srgb::from(buffer);
<span class="macro">assert_eq!</span>(srgb, Srgb::&lt;u8&gt;::new(<span class="number">255u8</span>, <span class="number">0</span>, <span class="number">255</span>));

<span class="kw">let </span>srgb_float: Srgb&lt;f32&gt; = srgb.into_format();
<span class="macro">assert_relative_eq!</span>(srgb_float, Srgb::new(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>));

<span class="kw">let </span>array: [u8; <span class="number">3</span>] = srgb_float.into_format().into();
<span class="macro">assert_eq!</span>(array, buffer);</code></pre></div>
<h2 id="a-basic-workflow"><a class="doc-anchor" href="#a-basic-workflow">§</a>A Basic Workflow</h2>
<p>The overall workflow can be divided into three steps, where the first and
last may be taken care of by other parts of the application:</p>
<div class="example-wrap"><pre class="language-text"><code>Decoding -&gt; Processing -&gt; Encoding
</code></pre></div><h3 id="1-decoding"><a class="doc-anchor" href="#1-decoding">§</a>1. Decoding</h3>
<p>Find out what the source format is and convert it to a linear color space.
There may be a specification, such as when working with SVG or CSS.</p>
<p>When working with RGB or gray scale (luma):</p>
<ul>
<li>
<p>If you are asking your user to enter an RGB value, you are in a gray zone
where it depends on the context. It’s usually safe to assume sRGB, but
sometimes it’s already linear.</p>
</li>
<li>
<p>If you are decoding an image, there may be some meta data that gives you
the necessary details. Otherwise it’s most commonly sRGB. Usually you will
end up with a slice or vector with RGB bytes, which can easily be converted
to Palette colors:</p>
</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>palette::{Srgb, cast::ComponentsAsMut};

<span class="comment">// This works for any color type (not only RGB) that can have the
// buffer element type as component.
</span><span class="kw">let </span>color_buffer: <span class="kw-2">&amp;mut </span>[Srgb&lt;u8&gt;] = image_buffer.components_as_mut();</code></pre></div>
<ul>
<li>If you are getting your colors from the GPU, in a game or other graphical
application, or if they are otherwise generated by the application, then
chances are that they are already linear. Still, make sure to check that
they are not being encoded somewhere.</li>
</ul>
<p>When working with other colors:</p>
<ul>
<li>
<p>For HSL, HSV, HWB: Check if they are based on any other color space than
sRGB, such as Adobe or Apple RGB.</p>
</li>
<li>
<p>For any of the CIE color spaces, check for a specification of white point
and light source. These are necessary for converting to RGB and other
colors, that depend on perception and “viewing devices”. Common defaults are
the D65 light source and the sRGB white point. The Palette defaults should
take you far.</p>
</li>
</ul>
<h3 id="2-processing"><a class="doc-anchor" href="#2-processing">§</a>2. Processing</h3>
<p>When your color has been decoded into some Palette type, it’s ready for
processing. This includes things like blending, hue shifting, darkening and
conversion to other formats. Just make sure that your non-linear RGB is made
linear first (<code>my_srgb.into_linear()</code>), to make the operations available.</p>
<p>Different color spaced have different capabilities, pros and cons. You may
have to experiment a bit (or look at the example programs) to find out what
gives the desired result.</p>
<h3 id="3-encoding"><a class="doc-anchor" href="#3-encoding">§</a>3. Encoding</h3>
<p>When the desired processing is done, it’s time to encode the colors back
into some image format. The same rules applies as for the decoding, but the
process reversed.</p>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.ColorDifference"><code>pub use color_difference::<a class="trait" href="color_difference/trait.ColorDifference.html" title="trait palette::color_difference::ColorDifference">ColorDifference</a>;</code></div><div class="desc docblock-short"><span class="stab deprecated" title="">Deprecated</span></div></li><li><div class="item-name" id="reexport.FromColor"><code>pub use convert::<a class="trait" href="convert/trait.FromColor.html" title="trait palette::convert::FromColor">FromColor</a>;</code></div></li><li><div class="item-name" id="reexport.FromColorMut"><code>pub use convert::<a class="trait" href="convert/trait.FromColorMut.html" title="trait palette::convert::FromColorMut">FromColorMut</a>;</code></div></li><li><div class="item-name" id="reexport.FromColorMutGuard"><code>pub use convert::<a class="struct" href="convert/struct.FromColorMutGuard.html" title="struct palette::convert::FromColorMutGuard">FromColorMutGuard</a>;</code></div></li><li><div class="item-name" id="reexport.IntoColor"><code>pub use convert::<a class="trait" href="convert/trait.IntoColor.html" title="trait palette::convert::IntoColor">IntoColor</a>;</code></div></li><li><div class="item-name" id="reexport.IntoColorMut"><code>pub use convert::<a class="trait" href="convert/trait.IntoColorMut.html" title="trait palette::convert::IntoColorMut">IntoColorMut</a>;</code></div></li></ul><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="alpha/index.html" title="mod palette::alpha">alpha</a></div><div class="desc docblock-short">Types related to transparent colors.</div></li><li><div class="item-name"><a class="mod" href="angle/index.html" title="mod palette::angle">angle</a></div><div class="desc docblock-short">Traits for working with angular values, such as for in hues.</div></li><li><div class="item-name"><a class="mod" href="blend/index.html" title="mod palette::blend">blend</a></div><div class="desc docblock-short">Color blending and blending equations.</div></li><li><div class="item-name"><a class="mod" href="bool_mask/index.html" title="mod palette::bool_mask">bool_mask</a></div><div class="desc docblock-short">Traits for abstracting over Boolean types.</div></li><li><div class="item-name"><a class="mod" href="cam16/index.html" title="mod palette::cam16">cam16</a></div><div class="desc docblock-short">Types for the CIE CAM16 color appearance model.</div></li><li><div class="item-name"><a class="mod" href="cast/index.html" title="mod palette::cast">cast</a></div><div class="desc docblock-short">Traits and functions for casting colors to and from other data types.</div></li><li><div class="item-name"><a class="mod" href="chromatic_adaptation/index.html" title="mod palette::chromatic_adaptation">chromatic_adaptation</a></div><div class="desc docblock-short">Convert colors from one reference white point to another</div></li><li><div class="item-name"><a class="mod" href="color_difference/index.html" title="mod palette::color_difference">color_difference</a></div><div class="desc docblock-short">Algorithms for calculating the difference between colors.</div></li><li><div class="item-name"><a class="mod" href="color_theory/index.html" title="mod palette::color_theory">color_theory</a></div><div class="desc docblock-short">Traits related to traditional color theory.</div></li><li><div class="item-name"><a class="mod" href="convert/index.html" title="mod palette::convert">convert</a></div><div class="desc docblock-short">Traits for converting between color spaces.</div></li><li><div class="item-name"><a class="mod" href="encoding/index.html" title="mod palette::encoding">encoding</a></div><div class="desc docblock-short">Number and color encoding traits, types and standards.</div></li><li><div class="item-name"><a class="mod" href="hsl/index.html" title="mod palette::hsl">hsl</a></div><div class="desc docblock-short">Types for the HSL color space.</div></li><li><div class="item-name"><a class="mod" href="hsluv/index.html" title="mod palette::hsluv">hsluv</a></div><div class="desc docblock-short">Types for the HSLuv color space.</div></li><li><div class="item-name"><a class="mod" href="hsv/index.html" title="mod palette::hsv">hsv</a></div><div class="desc docblock-short">Types for the HSV color space.</div></li><li><div class="item-name"><a class="mod" href="hues/index.html" title="mod palette::hues">hues</a></div><div class="desc docblock-short">Hues and hue related types.</div></li><li><div class="item-name"><a class="mod" href="hwb/index.html" title="mod palette::hwb">hwb</a></div><div class="desc docblock-short">Types for the HWB color space.</div></li><li><div class="item-name"><a class="mod" href="lab/index.html" title="mod palette::lab">lab</a></div><div class="desc docblock-short">Types for the CIE L*a*b* (CIELAB) color space.</div></li><li><div class="item-name"><a class="mod" href="lch/index.html" title="mod palette::lch">lch</a></div><div class="desc docblock-short">Types for the CIE L*C*h° color space.</div></li><li><div class="item-name"><a class="mod" href="lchuv/index.html" title="mod palette::lchuv">lchuv</a></div><div class="desc docblock-short">Types for the CIE L*C*uv h°uv color space.</div></li><li><div class="item-name"><a class="mod" href="luma/index.html" title="mod palette::luma">luma</a></div><div class="desc docblock-short">Types for luma and luminance (grayscale) values.</div></li><li><div class="item-name"><a class="mod" href="luv/index.html" title="mod palette::luv">luv</a></div><div class="desc docblock-short">Types for the CIE L*u*v* (CIELUV) color space.</div></li><li><div class="item-name"><a class="mod" href="named/index.html" title="mod palette::named">named</a></div><div class="desc docblock-short">A collection of named color constants. Can be toggled with the <code>&quot;named&quot;</code> and
<code>&quot;named_from_str&quot;</code> Cargo features.</div></li><li><div class="item-name"><a class="mod" href="num/index.html" title="mod palette::num">num</a></div><div class="desc docblock-short">Traits for abstracting over numeric types.</div></li><li><div class="item-name"><a class="mod" href="okhsl/index.html" title="mod palette::okhsl">okhsl</a></div><div class="desc docblock-short">Types for the Okhsl color space.</div></li><li><div class="item-name"><a class="mod" href="okhsv/index.html" title="mod palette::okhsv">okhsv</a></div><div class="desc docblock-short">Types for the Okhsv color space.</div></li><li><div class="item-name"><a class="mod" href="okhwb/index.html" title="mod palette::okhwb">okhwb</a></div><div class="desc docblock-short">Types for the Okhwb color space.</div></li><li><div class="item-name"><a class="mod" href="oklab/index.html" title="mod palette::oklab">oklab</a></div><div class="desc docblock-short">Types for the Oklab color space.</div></li><li><div class="item-name"><a class="mod" href="oklch/index.html" title="mod palette::oklch">oklch</a></div><div class="desc docblock-short">Types for the Oklch color space.</div></li><li><div class="item-name"><a class="mod" href="rgb/index.html" title="mod palette::rgb">rgb</a></div><div class="desc docblock-short">Types for the RGB color space, including spaces and standards.</div></li><li><div class="item-name"><a class="mod" href="serde/index.html" title="mod palette::serde">serde</a></div><div class="desc docblock-short">Utilities for serializing and deserializing with <code>serde</code>.</div></li><li><div class="item-name"><a class="mod" href="stimulus/index.html" title="mod palette::stimulus">stimulus</a></div><div class="desc docblock-short">Traits for working with stimulus colors and values, such as RGB and XYZ.</div></li><li><div class="item-name"><a class="mod" href="white_point/index.html" title="mod palette::white_point">white_point</a></div><div class="desc docblock-short">Defines the tristimulus values of the CIE Illuminants.</div></li><li><div class="item-name"><a class="mod" href="xyz/index.html" title="mod palette::xyz">xyz</a></div><div class="desc docblock-short">Types for the CIE 1931 XYZ color space.</div></li><li><div class="item-name"><a class="mod" href="yxy/index.html" title="mod palette::yxy">yxy</a></div><div class="desc docblock-short">Types for the CIE 1931 Yxy (xyY) color space.</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Alpha.html" title="struct palette::Alpha">Alpha</a></div><div class="desc docblock-short">An alpha component wrapper for colors, for adding transparency.</div></li><li><div class="item-name"><a class="struct" href="struct.Hsl.html" title="struct palette::Hsl">Hsl</a></div><div class="desc docblock-short">HSL color space.</div></li><li><div class="item-name"><a class="struct" href="struct.Hsluv.html" title="struct palette::Hsluv">Hsluv</a></div><div class="desc docblock-short">HSLuv color space.</div></li><li><div class="item-name"><a class="struct" href="struct.Hsv.html" title="struct palette::Hsv">Hsv</a></div><div class="desc docblock-short">HSV color space.</div></li><li><div class="item-name"><a class="struct" href="struct.Hwb.html" title="struct palette::Hwb">Hwb</a></div><div class="desc docblock-short">HWB color space.</div></li><li><div class="item-name"><a class="struct" href="struct.Lab.html" title="struct palette::Lab">Lab</a></div><div class="desc docblock-short">The CIE L*a*b* (CIELAB) color space.</div></li><li><div class="item-name"><a class="struct" href="struct.LabHue.html" title="struct palette::LabHue">LabHue</a></div><div class="desc docblock-short">A hue type for the CIE L*a*b* family of color spaces.</div></li><li><div class="item-name"><a class="struct" href="struct.Lch.html" title="struct palette::Lch">Lch</a></div><div class="desc docblock-short">CIE L*C*h°, a polar version of <a href="struct.Lab.html" title="struct palette::Lab">CIE L*a*b*</a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Lchuv.html" title="struct palette::Lchuv">Lchuv</a></div><div class="desc docblock-short">CIE L*C*uv h°uv, a polar version of <a href="struct.Luv.html" title="struct palette::Luv">CIE L*u*v*</a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Luv.html" title="struct palette::Luv">Luv</a></div><div class="desc docblock-short">The CIE L*u*v* (CIELUV) color space.</div></li><li><div class="item-name"><a class="struct" href="struct.LuvHue.html" title="struct palette::LuvHue">LuvHue</a></div><div class="desc docblock-short">A hue type for the CIE L*u*v* family of color spaces.</div></li><li><div class="item-name"><a class="struct" href="struct.Okhsl.html" title="struct palette::Okhsl">Okhsl</a></div><div class="desc docblock-short">A Hue/Saturation/Lightness representation of <a href="struct.Oklab.html" title="struct palette::Oklab"><code>Oklab</code></a> in the <code>sRGB</code> color space.</div></li><li><div class="item-name"><a class="struct" href="struct.Okhsv.html" title="struct palette::Okhsv">Okhsv</a></div><div class="desc docblock-short">A Hue/Saturation/Value representation of <a href="struct.Oklab.html" title="struct palette::Oklab"><code>Oklab</code></a> in the <code>sRGB</code> color space.</div></li><li><div class="item-name"><a class="struct" href="struct.Okhwb.html" title="struct palette::Okhwb">Okhwb</a></div><div class="desc docblock-short">A Hue/Whiteness/Blackness representation of <a href="struct.Oklab.html" title="struct palette::Oklab"><code>Oklab</code></a> in the
<code>sRGB</code> color space, similar to <a href="struct.Okhwb.html" title="struct palette::Okhwb"><code>Hwb</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Oklab.html" title="struct palette::Oklab">Oklab</a></div><div class="desc docblock-short">The <a href="https://bottosson.github.io/posts/oklab/">Oklab color space</a>.</div></li><li><div class="item-name"><a class="struct" href="struct.OklabHue.html" title="struct palette::OklabHue">OklabHue</a></div><div class="desc docblock-short">A hue type for the Oklab color space.</div></li><li><div class="item-name"><a class="struct" href="struct.Oklch.html" title="struct palette::Oklch">Oklch</a></div><div class="desc docblock-short">Oklch, a polar version of <a href="struct.Oklab.html" title="struct palette::Oklab">Oklab</a>.</div></li><li><div class="item-name"><a class="struct" href="struct.RgbHue.html" title="struct palette::RgbHue">RgbHue</a></div><div class="desc docblock-short">A hue type for the RGB family of color spaces.</div></li><li><div class="item-name"><a class="struct" href="struct.Xyz.html" title="struct palette::Xyz">Xyz</a></div><div class="desc docblock-short">The CIE 1931 XYZ color space.</div></li><li><div class="item-name"><a class="struct" href="struct.Yxy.html" title="struct palette::Yxy">Yxy</a></div><div class="desc docblock-short">The CIE 1931 Yxy (xyY) color space.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.ArrayExt.html" title="trait palette::ArrayExt">ArrayExt</a></div><div class="desc docblock-short">Extension trait for fixed size arrays.</div></li><li><div class="item-name"><a class="trait" href="trait.Clamp.html" title="trait palette::Clamp">Clamp</a></div><div class="desc docblock-short">An operator for restricting a color’s components to their expected ranges.</div></li><li><div class="item-name"><a class="trait" href="trait.ClampAssign.html" title="trait palette::ClampAssign">ClampAssign</a></div><div class="desc docblock-short">An assigning operator for restricting a color’s components to their expected
ranges.</div></li><li><div class="item-name"><a class="trait" href="trait.Darken.html" title="trait palette::Darken">Darken</a></div><div class="desc docblock-short">Operators for darkening a color;</div></li><li><div class="item-name"><a class="trait" href="trait.DarkenAssign.html" title="trait palette::DarkenAssign">DarkenAssign</a></div><div class="desc docblock-short">Assigning operators for darkening a color;</div></li><li><div class="item-name"><a class="trait" href="trait.Desaturate.html" title="trait palette::Desaturate">Desaturate</a></div><div class="desc docblock-short">Operator for decreasing the saturation (or chroma) of a color.</div></li><li><div class="item-name"><a class="trait" href="trait.DesaturateAssign.html" title="trait palette::DesaturateAssign">DesaturateAssign</a></div><div class="desc docblock-short">Assigning operator for decreasing the saturation (or chroma) of a color.</div></li><li><div class="item-name"><a class="trait" href="trait.GetHue.html" title="trait palette::GetHue">GetHue</a></div><div class="desc docblock-short">A trait for colors where a hue may be calculated.</div></li><li><div class="item-name"><a class="trait" href="trait.IsWithinBounds.html" title="trait palette::IsWithinBounds">IsWithinBounds</a></div><div class="desc docblock-short">Checks if color components are within their expected range bounds.</div></li><li><div class="item-name"><a class="trait" href="trait.Lighten.html" title="trait palette::Lighten">Lighten</a></div><div class="desc docblock-short">Operators for lightening a color.</div></li><li><div class="item-name"><a class="trait" href="trait.LightenAssign.html" title="trait palette::LightenAssign">LightenAssign</a></div><div class="desc docblock-short">Assigning operators for lightening a color.</div></li><li><div class="item-name"><a class="trait" href="trait.Mix.html" title="trait palette::Mix">Mix</a></div><div class="desc docblock-short">Linear color interpolation of two colors.</div></li><li><div class="item-name"><a class="trait" href="trait.MixAssign.html" title="trait palette::MixAssign">MixAssign</a></div><div class="desc docblock-short">Assigning linear color interpolation of two colors.</div></li><li><div class="item-name"><a class="trait" href="trait.NextArray.html" title="trait palette::NextArray">NextArray</a></div><div class="desc docblock-short">Temporary helper trait for getting an array type of size <code>N + 1</code>.</div></li><li><div class="item-name"><a class="trait" href="trait.RelativeContrast.html" title="trait palette::RelativeContrast">RelativeContrast</a><span class="stab deprecated" title="">Deprecated</span></div><div class="desc docblock-short">A trait for calculating relative contrast between two colors.</div></li><li><div class="item-name"><a class="trait" href="trait.Saturate.html" title="trait palette::Saturate">Saturate</a></div><div class="desc docblock-short">Operator for increasing the saturation (or chroma) of a color.</div></li><li><div class="item-name"><a class="trait" href="trait.SaturateAssign.html" title="trait palette::SaturateAssign">SaturateAssign</a></div><div class="desc docblock-short">Assigning operator for increasing the saturation (or chroma) of a color.</div></li><li><div class="item-name"><a class="trait" href="trait.SetHue.html" title="trait palette::SetHue">SetHue</a></div><div class="desc docblock-short">Change the hue of a color to a specific value without moving.</div></li><li><div class="item-name"><a class="trait" href="trait.ShiftHue.html" title="trait palette::ShiftHue">ShiftHue</a></div><div class="desc docblock-short">Operator for increasing or decreasing the hue by an amount.</div></li><li><div class="item-name"><a class="trait" href="trait.ShiftHueAssign.html" title="trait palette::ShiftHueAssign">ShiftHueAssign</a></div><div class="desc docblock-short">Assigning operator for increasing or decreasing the hue by an amount.</div></li><li><div class="item-name"><a class="trait" href="trait.WithAlpha.html" title="trait palette::WithAlpha">WithAlpha</a></div><div class="desc docblock-short">A trait for color types that can have or be given transparency (alpha channel).</div></li><li><div class="item-name"><a class="trait" href="trait.WithHue.html" title="trait palette::WithHue">WithHue</a></div><div class="desc docblock-short">Change the hue of a color to a specific value.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.contrast_ratio.html" title="fn palette::contrast_ratio">contrast_ratio</a><span class="stab deprecated" title="">Deprecated</span></div><div class="desc docblock-short">Calculate the ratio between two <code>luma</code> values.</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.GammaLuma.html" title="type palette::GammaLuma">GammaLuma</a></div><div class="desc docblock-short">Gamma 2.2 encoded luminance.</div></li><li><div class="item-name"><a class="type" href="type.GammaLumaa.html" title="type palette::GammaLumaa">GammaLumaa</a></div><div class="desc docblock-short">Gamma 2.2 encoded luminance with an alpha component.</div></li><li><div class="item-name"><a class="type" href="type.GammaSrgb.html" title="type palette::GammaSrgb">GammaSrgb</a></div><div class="desc docblock-short">Gamma 2.2 encoded sRGB.</div></li><li><div class="item-name"><a class="type" href="type.GammaSrgba.html" title="type palette::GammaSrgba">GammaSrgba</a></div><div class="desc docblock-short">Gamma 2.2 encoded sRGB with an alpha component.</div></li><li><div class="item-name"><a class="type" href="type.Hsla.html" title="type palette::Hsla">Hsla</a></div><div class="desc docblock-short">Linear HSL with an alpha component. See the <a href="alpha/struct.Alpha.html#Hsla" title="struct palette::alpha::Alpha"><code>Hsla</code> implementation in
<code>Alpha</code></a>.</div></li><li><div class="item-name"><a class="type" href="type.Hsluva.html" title="type palette::Hsluva">Hsluva</a></div><div class="desc docblock-short">HSLuv with an alpha component. See the <a href="alpha/struct.Alpha.html#Hsluva" title="struct palette::alpha::Alpha"><code>Hsluva</code> implementation in
<code>Alpha</code></a>.</div></li><li><div class="item-name"><a class="type" href="type.Hsva.html" title="type palette::Hsva">Hsva</a></div><div class="desc docblock-short">Linear HSV with an alpha component. See the <a href="alpha/struct.Alpha.html#Hsva" title="struct palette::alpha::Alpha"><code>Hsva</code> implementation in
<code>Alpha</code></a>.</div></li><li><div class="item-name"><a class="type" href="type.Hwba.html" title="type palette::Hwba">Hwba</a></div><div class="desc docblock-short">Linear HWB with an alpha component. See the <a href="alpha/struct.Alpha.html#Hwba" title="struct palette::alpha::Alpha"><code>Hwba</code> implementation in
<code>Alpha</code></a>.</div></li><li><div class="item-name"><a class="type" href="type.Laba.html" title="type palette::Laba">Laba</a></div><div class="desc docblock-short">CIE L*a*b* (CIELAB) with an alpha component. See the <a href="alpha/struct.Alpha.html#Laba" title="struct palette::alpha::Alpha"><code>Laba</code>
implementation in <code>Alpha</code></a>.</div></li><li><div class="item-name"><a class="type" href="type.Lcha.html" title="type palette::Lcha">Lcha</a></div><div class="desc docblock-short">CIE L*C*h° with an alpha component. See the <a href="alpha/struct.Alpha.html#Lcha" title="struct palette::alpha::Alpha"><code>Lcha</code> implementation in
<code>Alpha</code></a>.</div></li><li><div class="item-name"><a class="type" href="type.Lchuva.html" title="type palette::Lchuva">Lchuva</a></div><div class="desc docblock-short">CIE L*C*uv h°uv with an alpha component. See the <a href="alpha/struct.Alpha.html#Lchuva" title="struct palette::alpha::Alpha"><code>Lchuva</code> implementation in
<code>Alpha</code></a>.</div></li><li><div class="item-name"><a class="type" href="type.LinLuma.html" title="type palette::LinLuma">LinLuma</a></div><div class="desc docblock-short">Linear luminance.</div></li><li><div class="item-name"><a class="type" href="type.LinLumaa.html" title="type palette::LinLumaa">LinLumaa</a></div><div class="desc docblock-short">Linear luminance with an alpha component.</div></li><li><div class="item-name"><a class="type" href="type.LinSrgb.html" title="type palette::LinSrgb">LinSrgb</a></div><div class="desc docblock-short">Linear sRGB.</div></li><li><div class="item-name"><a class="type" href="type.LinSrgba.html" title="type palette::LinSrgba">LinSrgba</a></div><div class="desc docblock-short">Linear sRGB with an alpha component.</div></li><li><div class="item-name"><a class="type" href="type.Luva.html" title="type palette::Luva">Luva</a></div><div class="desc docblock-short">CIE L*u*v* (CIELUV) with an alpha component. See the <a href="alpha/struct.Alpha.html#Luva" title="struct palette::alpha::Alpha"><code>Luva</code>
implementation in <code>Alpha</code></a>.</div></li><li><div class="item-name"><a class="type" href="type.Mat3.html" title="type palette::Mat3">Mat3</a></div><div class="desc docblock-short">A 9 element array representing a 3x3 matrix.</div></li><li><div class="item-name"><a class="type" href="type.Okhsla.html" title="type palette::Okhsla">Okhsla</a></div><div class="desc docblock-short">Okhsl with an alpha component.</div></li><li><div class="item-name"><a class="type" href="type.Okhsva.html" title="type palette::Okhsva">Okhsva</a></div><div class="desc docblock-short">Okhsv with an alpha component. See the <a href="alpha/struct.Alpha.html#Okhsva" title="struct palette::alpha::Alpha"><code>Okhsva</code> implementation in
<code>Alpha</code></a>.</div></li><li><div class="item-name"><a class="type" href="type.Okhwba.html" title="type palette::Okhwba">Okhwba</a></div><div class="desc docblock-short">Okhwb with an alpha component. See the <a href="alpha/struct.Alpha.html#Okhwba" title="struct palette::alpha::Alpha"><code>Okhwba</code> implementation in
<code>Alpha</code></a>.</div></li><li><div class="item-name"><a class="type" href="type.Oklaba.html" title="type palette::Oklaba">Oklaba</a></div><div class="desc docblock-short">Oklab with an alpha component.</div></li><li><div class="item-name"><a class="type" href="type.Oklcha.html" title="type palette::Oklcha">Oklcha</a></div><div class="desc docblock-short">Oklch with an alpha component. See the <a href="alpha/struct.Alpha.html#Oklcha" title="struct palette::alpha::Alpha"><code>Oklcha</code> implementation in
<code>Alpha</code></a>.</div></li><li><div class="item-name"><a class="type" href="type.Srgb.html" title="type palette::Srgb">Srgb</a></div><div class="desc docblock-short">Non-linear sRGB, the most common RGB input/output format.</div></li><li><div class="item-name"><a class="type" href="type.SrgbLuma.html" title="type palette::SrgbLuma">SrgbLuma</a></div><div class="desc docblock-short">sRGB encoded luminance.</div></li><li><div class="item-name"><a class="type" href="type.SrgbLumaa.html" title="type palette::SrgbLumaa">SrgbLumaa</a></div><div class="desc docblock-short">sRGB encoded luminance with an alpha component.</div></li><li><div class="item-name"><a class="type" href="type.Srgba.html" title="type palette::Srgba">Srgba</a></div><div class="desc docblock-short">Non-linear sRGB with an alpha component.</div></li><li><div class="item-name"><a class="type" href="type.Xyza.html" title="type palette::Xyza">Xyza</a></div><div class="desc docblock-short">CIE 1931 XYZ with an alpha component. See the <a href="alpha/struct.Alpha.html#Xyza" title="struct palette::alpha::Alpha"><code>Xyza</code> implementation in
<code>Alpha</code></a>.</div></li><li><div class="item-name"><a class="type" href="type.Yxya.html" title="type palette::Yxya">Yxya</a></div><div class="desc docblock-short">CIE 1931 Yxy (xyY) with an alpha component. See the <a href="alpha/struct.Alpha.html#Yxya" title="struct palette::alpha::Alpha"><code>Yxya</code> implementation
in <code>Alpha</code></a>.</div></li></ul><h2 id="derives" class="section-header">Derive Macros<a href="#derives" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="derive" href="derive.WithAlpha.html" title="derive palette::WithAlpha">WithAlpha</a></div></li></ul></section></div></main></body></html>