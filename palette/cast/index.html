<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Traits and functions for casting colors to and from other data types."><title>palette::cast - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-ba5701c5741a7b69.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="palette" data-themes="" data-resource-suffix="" data-rustdoc-version="1.70.0 (90c541806 2023-05-31)" data-search-js="search-e077946657036a58.js" data-settings-js="settings-298e1ea74db45b39.js" data-settings-css="settings-7bfb4c59cc6bc502.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../../static.files/main-f61008743c98d196.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../palette/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../palette/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module cast</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#derives">Derive Macros</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">palette</a>::<wbr><a class="mod" href="#">cast</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../src/palette/cast.rs.html#1-152">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Traits and functions for casting colors to and from other data types.</p>
<p>The functions in this module casts without changing the underlying data. See
the <a href="../convert/index.html" title="mod palette::convert"><code>convert</code></a> module for how to convert between color
spaces.</p>
<h2 id="arrays-and-slices"><a href="#arrays-and-slices">Arrays and Slices</a></h2>
<p>Types that implement <a href="trait.ArrayCast.html" title="trait palette::cast::ArrayCast"><code>ArrayCast</code></a> can be cast to and from arrays and slices
with little to no overhead. This makes it easy to work with image buffers
and types from other crates without having to copy the data first.</p>
<h3 id="casting-arrays"><a href="#casting-arrays">Casting Arrays</a></h3>
<p>Arrays can be type checked to have the correct size at compile time, making
casting free after optimization has removed the overhead from asserts. The
same is true for arrays in slices and <code>Vec</code>s, because the length stays the
same after casting.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>palette::{cast, Srgb, IntoColor};

<span class="kw">let </span>color = cast::from_array::&lt;Srgb&lt;u8&gt;&gt;([<span class="number">23u8</span>, <span class="number">198</span>, <span class="number">76</span>]).into_linear();

<span class="kw">let </span>buffer = <span class="kw-2">&amp;mut </span>[[<span class="number">64u8</span>, <span class="number">139</span>, <span class="number">10</span>], [<span class="number">93</span>, <span class="number">18</span>, <span class="number">214</span>]];
<span class="kw">let </span>color_buffer = cast::from_array_slice_mut::&lt;Srgb&lt;u8&gt;&gt;(buffer);

<span class="kw">for </span>destination <span class="kw">in </span>color_buffer {
    <span class="kw">let </span>linear_dst = destination.into_linear::&lt;f32&gt;();
    <span class="kw-2">*</span>destination = (linear_dst + color).into_encoding();
}</code></pre></div>
<p>Trying to cast an array of the wrong size will not compile:</p>

<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>palette::{cast, Srgb};

<span class="kw">let </span>color = cast::from_array::&lt;Srgb&lt;u8&gt;&gt;([<span class="number">23u8</span>, <span class="number">198</span>]); <span class="comment">// Too few components.</span></code></pre></div>
<h3 id="casting-component-buffers"><a href="#casting-component-buffers">Casting Component Buffers</a></h3>
<p>This is a common situation is image processing, where you have an image
buffer, such as <code>&amp;mut [u8]</code>, <code>&amp;mut [f32]</code>, <code>Vec&lt;u8&gt;</code> or <code>Vec&lt;f32&gt;</code>, that you
want to work with as colors. This buffer may, for example, be the content of
an image file or shared with the GPU.</p>
<p>The downside, compared to having fixed size arrays, is that the length
cannot be statically known to be a multiple of the color type’s array
length. This adds a bit of error handling overhead, as well as for dividing
or multiplying the length.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>palette::{cast, Srgb};

<span class="kw">let </span>correct_buffer = <span class="kw-2">&amp;</span>[<span class="number">64u8</span>, <span class="number">139</span>, <span class="number">10</span>, <span class="number">93</span>, <span class="number">18</span>, <span class="number">214</span>];
<span class="macro">assert!</span>(cast::try_from_component_slice::&lt;Srgb&lt;u8&gt;&gt;(correct_buffer).is_ok());

<span class="kw">let </span>incorrect_buffer = <span class="kw-2">&amp;</span>[<span class="number">64u8</span>, <span class="number">139</span>, <span class="number">10</span>, <span class="number">93</span>, <span class="number">18</span>, <span class="number">214</span>, <span class="number">198</span>, <span class="number">76</span>];
<span class="macro">assert!</span>(cast::try_from_component_slice::&lt;Srgb&lt;u8&gt;&gt;(incorrect_buffer).is_err());</code></pre></div>
<p>An alternative, for when the length can be trusted to be correct, is to use
the <code>from_component_*</code> functions that panic on error.</p>
<p>This works:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>palette::{cast, Srgb};

<span class="kw">let </span>correct_buffer = <span class="kw-2">&amp;</span>[<span class="number">64u8</span>, <span class="number">139</span>, <span class="number">10</span>, <span class="number">93</span>, <span class="number">18</span>, <span class="number">214</span>];
<span class="kw">let </span>color_buffer = cast::from_component_slice::&lt;Srgb&lt;u8&gt;&gt;(correct_buffer);</code></pre></div>
<p>But this panics:</p>

<div class="example-wrap should_panic"><a href="#" class="tooltip" title="This example panics">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>palette::{cast, Srgb};

<span class="kw">let </span>incorrect_buffer = <span class="kw-2">&amp;</span>[<span class="number">64u8</span>, <span class="number">139</span>, <span class="number">10</span>, <span class="number">93</span>, <span class="number">18</span>, <span class="number">214</span>, <span class="number">198</span>, <span class="number">76</span>];
<span class="kw">let </span>color_buffer = cast::from_component_slice::&lt;Srgb&lt;u8&gt;&gt;(incorrect_buffer);</code></pre></div>
<h3 id="casting-single-colors"><a href="#casting-single-colors">Casting Single Colors</a></h3>
<p>The built-in color types implement <code>AsRef</code>, <code>AsMut</code>, <code>From</code>, <code>Into</code>,
<code>TryFrom</code> and <code>TryInto</code> in addition to <code>ArrayCast</code> for convenient casting of
single colors:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>core::convert::TryFrom;
<span class="kw">use </span>palette::Srgb;

<span class="kw">let </span>color = Srgb::from([<span class="number">23u8</span>, <span class="number">198</span>, <span class="number">76</span>]);
<span class="kw">let </span>array: [u8; <span class="number">3</span>] = color.into();

<span class="kw">let </span>slice: <span class="kw-2">&amp;</span>[u8] = color.as_ref();
<span class="macro">assert!</span>(&lt;<span class="kw-2">&amp;</span>Srgb&lt;u8&gt;&gt;::try_from(slice).is_ok());

<span class="kw">let </span>short_slice: <span class="kw-2">&amp;</span>[f32] = <span class="kw-2">&amp;</span>[<span class="number">0.1</span>, <span class="number">0.5</span>];
<span class="macro">assert!</span>(&lt;<span class="kw-2">&amp;</span>Srgb&gt;::try_from(short_slice).is_err()); <span class="comment">// Too few components.</span></code></pre></div>
<h3 id="component-order"><a href="#component-order">Component Order</a></h3>
<p>The component order in an array or slice is not always the same as in the
color types. For example, a byte buffer that is encoded as ARGB will not
cast to correct <code>Rgba</code> values. The components can be reordered after casting
by using the <a href="struct.Packed.html" title="struct palette::cast::Packed"><code>Packed</code></a> wrapper as an intermediate representation.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// `PackedArgb` is an alias for `Packed&lt;rgb::channels::Argb, P = u32&gt;`.
</span><span class="kw">use </span>palette::{rgb::PackedArgb, cast, Srgba};

<span class="kw">let </span>components = <span class="kw-2">&amp;</span>[<span class="number">1.0f32</span>, <span class="number">0.8</span>, <span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">1.0</span>, <span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">0.6</span>];
<span class="kw">let </span>colors = cast::from_component_slice::&lt;PackedArgb&lt;<span class="kw">_</span>&gt;&gt;(components);

<span class="comment">// Notice how the alpha values have moved from the beginning to the end:
</span><span class="macro">assert_eq!</span>(Srgba::from(colors[<span class="number">0</span>]), Srgba::new(<span class="number">0.8</span>, <span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">1.0</span>));
<span class="macro">assert_eq!</span>(Srgba::from(colors[<span class="number">1</span>]), Srgba::new(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">1.0</span>));</code></pre></div>
<h2 id="unsigned-integers"><a href="#unsigned-integers">Unsigned Integers</a></h2>
<p>Types that implement <a href="trait.UintCast.html" title="trait palette::cast::UintCast"><code>UintCast</code></a> can be cast to and from unsigned integers
of the same size. It’s a bit more limited than slices and arrays but it’s
useful for common patterns like representing RGBA values as hexadecimal
unsigned integers.</p>
<p>The <a href="struct.Packed.html" title="struct palette::cast::Packed"><code>Packed</code></a> wrapper can be used as an intermediate format to make
unpacking the values as simple as <code>from</code> or <code>into</code>. It’s also possible to
choose a channel order to be something other than what the default <code>From</code>
implementations would use.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// `PackedArgb` is an alias for `Packed&lt;rgb::channels::Argb, P = u32&gt;`.
</span><span class="kw">use </span>palette::{rgb::PackedArgb, cast, Srgba};

<span class="kw">let </span>raw = <span class="kw-2">&amp;</span>[<span class="number">0xFF7F0080u32</span>, <span class="number">0xFF60BBCC</span>];
<span class="kw">let </span>colors = cast::from_uint_slice::&lt;PackedArgb&gt;(raw);

<span class="macro">assert_eq!</span>(colors.len(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(Srgba::from(colors[<span class="number">0</span>]), Srgba::new(<span class="number">0x7F</span>, <span class="number">0x00</span>, <span class="number">0x80</span>, <span class="number">0xFF</span>));
<span class="macro">assert_eq!</span>(Srgba::from(colors[<span class="number">1</span>]), Srgba::new(<span class="number">0x60</span>, <span class="number">0xBB</span>, <span class="number">0xCC</span>, <span class="number">0xFF</span>));</code></pre></div>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.BoxedSliceCastError.html" title="struct palette::cast::BoxedSliceCastError">BoxedSliceCastError</a></div><div class="desc docblock-short">The error type returned when casting a boxed slice of components fails.</div></li><li><div class="item-name"><a class="struct" href="struct.Packed.html" title="struct palette::cast::Packed">Packed</a></div><div class="desc docblock-short">A color packed into a compact format, such as an unsigned integer.</div></li><li><div class="item-name"><a class="struct" href="struct.SliceCastError.html" title="struct palette::cast::SliceCastError">SliceCastError</a></div><div class="desc docblock-short">The error type returned when casting a slice of components fails.</div></li><li><div class="item-name"><a class="struct" href="struct.VecCastError.html" title="struct palette::cast::VecCastError">VecCastError</a></div><div class="desc docblock-short">The error type returned when casting a <code>Vec</code> of components fails.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.VecCastErrorKind.html" title="enum palette::cast::VecCastErrorKind">VecCastErrorKind</a></div><div class="desc docblock-short">The type of error that is returned when casting a <code>Vec</code> of components.</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.ArrayCast.html" title="trait palette::cast::ArrayCast">ArrayCast</a></div><div class="desc docblock-short">Marker trait for types that can be represented as a fixed size array.</div></li><li><div class="item-name"><a class="trait" href="trait.ComponentOrder.html" title="trait palette::cast::ComponentOrder">ComponentOrder</a></div><div class="desc docblock-short">Packs and unpacks color types with some component order.</div></li><li><div class="item-name"><a class="trait" href="trait.UintCast.html" title="trait palette::cast::UintCast">UintCast</a></div><div class="desc docblock-short">Marker trait for types that can be represented as an unsigned integer.</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.from_array.html" title="fn palette::cast::from_array">from_array</a></div><div class="desc docblock-short">Cast from an array to a color type.</div></li><li><div class="item-name"><a class="fn" href="fn.from_array_box.html" title="fn palette::cast::from_array_box">from_array_box</a></div><div class="desc docblock-short">Cast from a boxed array to a boxed color type.</div></li><li><div class="item-name"><a class="fn" href="fn.from_array_mut.html" title="fn palette::cast::from_array_mut">from_array_mut</a></div><div class="desc docblock-short">Cast from a mutable array reference to a mutable color type reference.</div></li><li><div class="item-name"><a class="fn" href="fn.from_array_ref.html" title="fn palette::cast::from_array_ref">from_array_ref</a></div><div class="desc docblock-short">Cast from an array reference to a color type reference.</div></li><li><div class="item-name"><a class="fn" href="fn.from_array_slice.html" title="fn palette::cast::from_array_slice">from_array_slice</a></div><div class="desc docblock-short">Cast from a slice of arrays to a slice of colors.</div></li><li><div class="item-name"><a class="fn" href="fn.from_array_slice_box.html" title="fn palette::cast::from_array_slice_box">from_array_slice_box</a></div><div class="desc docblock-short">Cast from a boxed slice of arrays to a boxed slice of colors.</div></li><li><div class="item-name"><a class="fn" href="fn.from_array_slice_mut.html" title="fn palette::cast::from_array_slice_mut">from_array_slice_mut</a></div><div class="desc docblock-short">Cast from a mutable slice of arrays to a mutable slice of colors.</div></li><li><div class="item-name"><a class="fn" href="fn.from_array_vec.html" title="fn palette::cast::from_array_vec">from_array_vec</a></div><div class="desc docblock-short">Cast from a <code>Vec</code> of arrays to a <code>Vec</code> of colors.</div></li><li><div class="item-name"><a class="fn" href="fn.from_component_slice.html" title="fn palette::cast::from_component_slice">from_component_slice</a></div><div class="desc docblock-short">The same as <a href="fn.try_from_component_slice.html" title="fn palette::cast::try_from_component_slice"><code>try_from_component_slice</code></a> but panics on error.</div></li><li><div class="item-name"><a class="fn" href="fn.from_component_slice_box.html" title="fn palette::cast::from_component_slice_box">from_component_slice_box</a></div><div class="desc docblock-short">The same as <a href="fn.try_from_component_slice_box.html" title="fn palette::cast::try_from_component_slice_box"><code>try_from_component_slice_box</code></a> but panics on error.</div></li><li><div class="item-name"><a class="fn" href="fn.from_component_slice_mut.html" title="fn palette::cast::from_component_slice_mut">from_component_slice_mut</a></div><div class="desc docblock-short">The same as <a href="fn.try_from_component_slice_mut.html" title="fn palette::cast::try_from_component_slice_mut"><code>try_from_component_slice_mut</code></a> but panics on error.</div></li><li><div class="item-name"><a class="fn" href="fn.from_component_vec.html" title="fn palette::cast::from_component_vec">from_component_vec</a></div><div class="desc docblock-short">The same as <a href="fn.try_from_component_vec.html" title="fn palette::cast::try_from_component_vec"><code>try_from_component_vec</code></a> but panics on error.</div></li><li><div class="item-name"><a class="fn" href="fn.from_uint.html" title="fn palette::cast::from_uint">from_uint</a></div><div class="desc docblock-short">Cast from an unsigned integer to a color type.</div></li><li><div class="item-name"><a class="fn" href="fn.from_uint_mut.html" title="fn palette::cast::from_uint_mut">from_uint_mut</a></div><div class="desc docblock-short">Cast from a mutable unsigned integer reference to a mutable color type reference.</div></li><li><div class="item-name"><a class="fn" href="fn.from_uint_ref.html" title="fn palette::cast::from_uint_ref">from_uint_ref</a></div><div class="desc docblock-short">Cast from an unsigned integer reference to a color type reference.</div></li><li><div class="item-name"><a class="fn" href="fn.from_uint_slice.html" title="fn palette::cast::from_uint_slice">from_uint_slice</a></div><div class="desc docblock-short">Cast from a slice of unsigned integers to a slice of colors.</div></li><li><div class="item-name"><a class="fn" href="fn.from_uint_slice_box.html" title="fn palette::cast::from_uint_slice_box">from_uint_slice_box</a></div><div class="desc docblock-short">Cast from a boxed slice of unsigned integers to a boxed slice of colors.</div></li><li><div class="item-name"><a class="fn" href="fn.from_uint_slice_mut.html" title="fn palette::cast::from_uint_slice_mut">from_uint_slice_mut</a></div><div class="desc docblock-short">Cast from a mutable slice of unsigned integers to a mutable slice of colors.</div></li><li><div class="item-name"><a class="fn" href="fn.from_uint_vec.html" title="fn palette::cast::from_uint_vec">from_uint_vec</a></div><div class="desc docblock-short">Cast from a <code>Vec</code> of unsigned integers to a <code>Vec</code> of colors.</div></li><li><div class="item-name"><a class="fn" href="fn.into_array.html" title="fn palette::cast::into_array">into_array</a></div><div class="desc docblock-short">Cast from a color type to an array.</div></li><li><div class="item-name"><a class="fn" href="fn.into_array_box.html" title="fn palette::cast::into_array_box">into_array_box</a></div><div class="desc docblock-short">Cast from a boxed color type to a boxed array.</div></li><li><div class="item-name"><a class="fn" href="fn.into_array_mut.html" title="fn palette::cast::into_array_mut">into_array_mut</a></div><div class="desc docblock-short">Cast from a mutable color type reference to a mutable array reference.</div></li><li><div class="item-name"><a class="fn" href="fn.into_array_ref.html" title="fn palette::cast::into_array_ref">into_array_ref</a></div><div class="desc docblock-short">Cast from a color type reference to an array reference.</div></li><li><div class="item-name"><a class="fn" href="fn.into_array_slice.html" title="fn palette::cast::into_array_slice">into_array_slice</a></div><div class="desc docblock-short">Cast from a slice of colors to a slice of arrays.</div></li><li><div class="item-name"><a class="fn" href="fn.into_array_slice_box.html" title="fn palette::cast::into_array_slice_box">into_array_slice_box</a></div><div class="desc docblock-short">Cast from a boxed slice of colors to a boxed slice of arrays.</div></li><li><div class="item-name"><a class="fn" href="fn.into_array_slice_mut.html" title="fn palette::cast::into_array_slice_mut">into_array_slice_mut</a></div><div class="desc docblock-short">Cast from a mutable slice of colors to a mutable slice of arrays.</div></li><li><div class="item-name"><a class="fn" href="fn.into_array_vec.html" title="fn palette::cast::into_array_vec">into_array_vec</a></div><div class="desc docblock-short">Cast from a <code>Vec</code> of colors to a <code>Vec</code> of arrays.</div></li><li><div class="item-name"><a class="fn" href="fn.into_component_slice.html" title="fn palette::cast::into_component_slice">into_component_slice</a></div><div class="desc docblock-short">Cast from a slice of colors to a slice of color components.</div></li><li><div class="item-name"><a class="fn" href="fn.into_component_slice_box.html" title="fn palette::cast::into_component_slice_box">into_component_slice_box</a></div><div class="desc docblock-short">Cast from a boxed slice of colors to a boxed slice of color components.</div></li><li><div class="item-name"><a class="fn" href="fn.into_component_slice_mut.html" title="fn palette::cast::into_component_slice_mut">into_component_slice_mut</a></div><div class="desc docblock-short">Cast from a slice of colors to a slice of color components.</div></li><li><div class="item-name"><a class="fn" href="fn.into_component_vec.html" title="fn palette::cast::into_component_vec">into_component_vec</a></div><div class="desc docblock-short">Cast from a <code>Vec</code> of colors to a <code>Vec</code> of color components.</div></li><li><div class="item-name"><a class="fn" href="fn.into_uint.html" title="fn palette::cast::into_uint">into_uint</a></div><div class="desc docblock-short">Cast from a color type to an unsigned integer.</div></li><li><div class="item-name"><a class="fn" href="fn.into_uint_mut.html" title="fn palette::cast::into_uint_mut">into_uint_mut</a></div><div class="desc docblock-short">Cast from a mutable color type reference to a mutable unsigned integer reference.</div></li><li><div class="item-name"><a class="fn" href="fn.into_uint_ref.html" title="fn palette::cast::into_uint_ref">into_uint_ref</a></div><div class="desc docblock-short">Cast from a color type reference to an unsigned integer reference.</div></li><li><div class="item-name"><a class="fn" href="fn.into_uint_slice.html" title="fn palette::cast::into_uint_slice">into_uint_slice</a></div><div class="desc docblock-short">Cast from a slice of colors to a slice of unsigned integers.</div></li><li><div class="item-name"><a class="fn" href="fn.into_uint_slice_box.html" title="fn palette::cast::into_uint_slice_box">into_uint_slice_box</a></div><div class="desc docblock-short">Cast from a boxed slice of colors to a boxed slice of unsigned integers.</div></li><li><div class="item-name"><a class="fn" href="fn.into_uint_slice_mut.html" title="fn palette::cast::into_uint_slice_mut">into_uint_slice_mut</a></div><div class="desc docblock-short">Cast from a mutable slice of colors to a mutable slice of unsigned integers.</div></li><li><div class="item-name"><a class="fn" href="fn.into_uint_vec.html" title="fn palette::cast::into_uint_vec">into_uint_vec</a></div><div class="desc docblock-short">Cast from a <code>Vec</code> of colors to a <code>Vec</code> of unsigned integers.</div></li><li><div class="item-name"><a class="fn" href="fn.map_slice_box_in_place.html" title="fn palette::cast::map_slice_box_in_place">map_slice_box_in_place</a></div><div class="desc docblock-short">Map values of color A to values of color B without creating a new <code>Box&lt;[B]&gt;</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.map_vec_in_place.html" title="fn palette::cast::map_vec_in_place">map_vec_in_place</a></div><div class="desc docblock-short">Map values of color A to values of color B without creating a new <code>Vec</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.try_from_component_slice.html" title="fn palette::cast::try_from_component_slice">try_from_component_slice</a></div><div class="desc docblock-short">Cast from a slice of color components to a slice of colors.</div></li><li><div class="item-name"><a class="fn" href="fn.try_from_component_slice_box.html" title="fn palette::cast::try_from_component_slice_box">try_from_component_slice_box</a></div><div class="desc docblock-short">Cast from a boxed slice of color components to a boxed slice of colors.</div></li><li><div class="item-name"><a class="fn" href="fn.try_from_component_slice_mut.html" title="fn palette::cast::try_from_component_slice_mut">try_from_component_slice_mut</a></div><div class="desc docblock-short">Cast from a mutable slice of color components to a slice of colors.</div></li><li><div class="item-name"><a class="fn" href="fn.try_from_component_vec.html" title="fn palette::cast::try_from_component_vec">try_from_component_vec</a></div><div class="desc docblock-short">Cast from a <code>Vec</code> of color components to a <code>Vec</code> of colors.</div></li></ul><h2 id="derives" class="small-section-header"><a href="#derives">Derive Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="derive" href="derive.ArrayCast.html" title="derive palette::cast::ArrayCast">ArrayCast</a></div></li></ul></section></div></main></body></html>