<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Traits and functions for casting colors to and from other data types."><meta name="keywords" content="rust, rustlang, rust-lang, cast"><title>palette::cast - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings"></script><script src="../../storage.js"></script><script src="../../crates.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../favicon.svg">
<link rel="alternate icon" type="image/png" href="../../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../palette/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a><h2 class="location">Module cast</h2><div class="sidebar-elems"><div class="block items"><ul><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></div><div id="sidebar-vars" data-name="cast" data-ty="mod" data-relpath="./"></div><script defer src="./sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img src="../../brush.svg" width="18" height="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img src="../../wheel.svg" width="18" height="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Module <a href="../index.html">palette</a>::<wbr><a class="mod" href="#">cast</a><button id="copy-path" onclick="copy_path(this)" title="copy path"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item import" title="Copy item import to clipboard"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/palette/cast.rs.html#1-154" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Traits and functions for casting colors to and from other data types.</p>
<p>The functions in this module casts without changing the underlying data. See
the <a href="../convert/index.html"><code>convert</code></a> module for how to convert between color
spaces.</p>
<h1 id="arrays-and-slices" class="section-header"><a href="#arrays-and-slices">Arrays and Slices</a></h1>
<p>Types that implement <a href="trait.ArrayCast.html" title="ArrayCast"><code>ArrayCast</code></a> can be cast to and from arrays and slices
with little to no overhead. This makes it easy to work with image buffers
and types from other crates without having to copy the data first.</p>
<h2 id="casting-arrays" class="section-header"><a href="#casting-arrays">Casting Arrays</a></h2>
<p>Arrays can be type checked to have the correct size at compile time, making
casting free after optimization has removed the overhead from asserts. The
same is true for arrays in slices and <code>Vec</code>s, because the length stays the
same after casting.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">palette</span>::{<span class="ident">cast</span>, <span class="ident">Srgb</span>, <span class="ident">IntoColor</span>};

<span class="kw">let</span> <span class="ident">color</span> <span class="op">=</span> <span class="ident">cast::from_array</span>::<span class="op">&lt;</span><span class="ident">Srgb</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span><span class="op">&gt;</span>([<span class="number">23u8</span>, <span class="number">198</span>, <span class="number">76</span>])
    .<span class="ident">into_format</span>::<span class="op">&lt;</span><span class="ident">f32</span><span class="op">&gt;</span>()
    .<span class="ident">into_linear</span>();

<span class="kw">let</span> <span class="ident">buffer</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [[<span class="number">64u8</span>, <span class="number">139</span>, <span class="number">10</span>], [<span class="number">93</span>, <span class="number">18</span>, <span class="number">214</span>]];
<span class="kw">let</span> <span class="ident">color_buffer</span> <span class="op">=</span> <span class="ident">cast::from_array_slice_mut</span>::<span class="op">&lt;</span><span class="ident">Srgb</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span><span class="op">&gt;</span>(<span class="ident">buffer</span>);

<span class="kw">for</span> <span class="ident">destination</span> <span class="kw">in</span> <span class="ident">color_buffer</span> {
    <span class="kw">let</span> <span class="ident">linear_dst</span> <span class="op">=</span> <span class="ident">destination</span>.<span class="ident">into_format</span>().<span class="ident">into_linear</span>();
    <span class="kw-2">*</span><span class="ident">destination</span> <span class="op">=</span> (<span class="ident">linear_dst</span> <span class="op">+</span> <span class="ident">color</span>).<span class="ident">into_encoding</span>().<span class="ident">into_format</span>();
}</pre></div>
<p>Trying to cast an array of the wrong size will not compile:</p>

<div class='information'><div class='tooltip compile_fail'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered compile_fail">
<span class="kw">use</span> <span class="ident">palette</span>::{<span class="ident">cast</span>, <span class="ident">Srgb</span>};

<span class="kw">let</span> <span class="ident">color</span> <span class="op">=</span> <span class="ident">cast::from_array</span>::<span class="op">&lt;</span><span class="ident">Srgb</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span><span class="op">&gt;</span>([<span class="number">23u8</span>, <span class="number">198</span>]); <span class="comment">// Too few components.</span></pre></div>
<h2 id="casting-component-buffers" class="section-header"><a href="#casting-component-buffers">Casting Component Buffers</a></h2>
<p>This is a common situation is image processing, where you have an image
buffer, such as <code>&amp;mut [u8]</code>, <code>&amp;mut [f32]</code>, <code>Vec&lt;u8&gt;</code> or <code>Vec&lt;f32&gt;</code>, that you
want to work with as colors. This buffer may, for example, be the content of
an image file or shared with the GPU.</p>
<p>The downside, compared to having fixed size arrays, is that the length
cannot be statically known to be a multiple of the color type’s array
length. This adds a bit of error handling overhead, as well as for dividing
or multiplying the length.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">palette</span>::{<span class="ident">cast</span>, <span class="ident">Srgb</span>};

<span class="kw">let</span> <span class="ident">correct_buffer</span> <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="number">64u8</span>, <span class="number">139</span>, <span class="number">10</span>, <span class="number">93</span>, <span class="number">18</span>, <span class="number">214</span>];
<span class="macro">assert!</span>(<span class="ident">cast::try_from_component_slice</span>::<span class="op">&lt;</span><span class="ident">Srgb</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span><span class="op">&gt;</span>(<span class="ident">correct_buffer</span>).<span class="ident">is_ok</span>());

<span class="kw">let</span> <span class="ident">incorrect_buffer</span> <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="number">64u8</span>, <span class="number">139</span>, <span class="number">10</span>, <span class="number">93</span>, <span class="number">18</span>, <span class="number">214</span>, <span class="number">198</span>, <span class="number">76</span>];
<span class="macro">assert!</span>(<span class="ident">cast::try_from_component_slice</span>::<span class="op">&lt;</span><span class="ident">Srgb</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span><span class="op">&gt;</span>(<span class="ident">incorrect_buffer</span>).<span class="ident">is_err</span>());</pre></div>
<p>An alternative, for when the length can be trusted to be correct, is to use
the <code>from_component_*</code> functions that panic on error.</p>
<p>This works:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">palette</span>::{<span class="ident">cast</span>, <span class="ident">Srgb</span>};

<span class="kw">let</span> <span class="ident">correct_buffer</span> <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="number">64u8</span>, <span class="number">139</span>, <span class="number">10</span>, <span class="number">93</span>, <span class="number">18</span>, <span class="number">214</span>];
<span class="kw">let</span> <span class="ident">color_buffer</span> <span class="op">=</span> <span class="ident">cast::from_component_slice</span>::<span class="op">&lt;</span><span class="ident">Srgb</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span><span class="op">&gt;</span>(<span class="ident">correct_buffer</span>);</pre></div>
<p>But this panics:</p>

<div class='information'><div class='tooltip should_panic'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered should_panic">
<span class="kw">use</span> <span class="ident">palette</span>::{<span class="ident">cast</span>, <span class="ident">Srgb</span>};

<span class="kw">let</span> <span class="ident">incorrect_buffer</span> <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="number">64u8</span>, <span class="number">139</span>, <span class="number">10</span>, <span class="number">93</span>, <span class="number">18</span>, <span class="number">214</span>, <span class="number">198</span>, <span class="number">76</span>];
<span class="kw">let</span> <span class="ident">color_buffer</span> <span class="op">=</span> <span class="ident">cast::from_component_slice</span>::<span class="op">&lt;</span><span class="ident">Srgb</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span><span class="op">&gt;</span>(<span class="ident">incorrect_buffer</span>);</pre></div>
<h2 id="casting-single-colors" class="section-header"><a href="#casting-single-colors">Casting Single Colors</a></h2>
<p>The built-in color types implement <code>AsRef</code>, <code>AsMut</code>, <code>From</code>, <code>Into</code>,
<code>TryFrom</code> and <code>TryInto</code> in addition to <code>ArrayCast</code> for convenient casting of
single colors:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">core::convert::TryFrom</span>;
<span class="kw">use</span> <span class="ident">palette::Srgb</span>;

<span class="kw">let</span> <span class="ident">color</span> <span class="op">=</span> <span class="ident">Srgb::from</span>([<span class="number">23u8</span>, <span class="number">198</span>, <span class="number">76</span>]);
<span class="kw">let</span> <span class="ident">array</span>: [<span class="ident">u8</span>; <span class="number">3</span>] <span class="op">=</span> <span class="ident">color</span>.<span class="ident">into</span>();

<span class="kw">let</span> <span class="ident">slice</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>] <span class="op">=</span> <span class="ident">color</span>.<span class="ident">as_ref</span>();
<span class="macro">assert!</span>(<span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">Srgb</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="ident">::try_from</span>(<span class="ident">slice</span>).<span class="ident">is_ok</span>());

<span class="kw">let</span> <span class="ident">short_slice</span>: <span class="kw-2">&amp;</span>[<span class="ident">f32</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="number">0.1</span>, <span class="number">0.5</span>];
<span class="macro">assert!</span>(<span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">Srgb</span><span class="op">&gt;</span><span class="ident">::try_from</span>(<span class="ident">short_slice</span>).<span class="ident">is_err</span>()); <span class="comment">// Too few components.</span></pre></div>
<h2 id="component-order" class="section-header"><a href="#component-order">Component Order</a></h2>
<p>The component order in an array or slice is not always the same as in the
color types. For example, a byte buffer that is encoded as ARGB will not
cast to correct <code>Rgba</code> values. The components can be reordered after casting
by using the <a href="struct.Packed.html" title="Packed"><code>Packed</code></a> wrapper as an intermediate representation.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// `PackedArgb` is an alias for `Packed&lt;rgb::channels::Argb, P = u32&gt;`.</span>
<span class="kw">use</span> <span class="ident">palette</span>::{<span class="ident">rgb::PackedArgb</span>, <span class="ident">cast</span>, <span class="ident">Srgba</span>};

<span class="kw">let</span> <span class="ident">components</span> <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="number">1.0f32</span>, <span class="number">0.8</span>, <span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">1.0</span>, <span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">0.6</span>];
<span class="kw">let</span> <span class="ident">colors</span> <span class="op">=</span> <span class="ident">cast::from_component_slice</span>::<span class="op">&lt;</span><span class="ident">PackedArgb</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span><span class="op">&gt;</span>(<span class="ident">components</span>);

<span class="comment">// Notice how the alpha values have moved from the beginning to the end:</span>
<span class="macro">assert_eq!</span>(<span class="ident">Srgba::from</span>(<span class="ident">colors</span>[<span class="number">0</span>]), <span class="ident">Srgba::new</span>(<span class="number">0.8</span>, <span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">1.0</span>));
<span class="macro">assert_eq!</span>(<span class="ident">Srgba::from</span>(<span class="ident">colors</span>[<span class="number">1</span>]), <span class="ident">Srgba::new</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">1.0</span>));</pre></div>
<h1 id="unsigned-integers" class="section-header"><a href="#unsigned-integers">Unsigned Integers</a></h1>
<p>Types that implement <a href="trait.UintCast.html" title="UintCast"><code>UintCast</code></a> can be cast to and from unsigned integers
of the same size. It’s a bit more limited than slices and arrays but it’s
useful for common patterns like representing RGBA values as hexadecimal
unsigned integers.</p>
<p>The <a href="struct.Packed.html" title="Packed"><code>Packed</code></a> wrapper can be used as an intermediate format to make
unpacking the values as simple as <code>from</code> or <code>into</code>. It’s also possible to
choose a channel order to be something other than what the default <code>From</code>
implementations would use.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// `PackedArgb` is an alias for `Packed&lt;rgb::channels::Argb, P = u32&gt;`.</span>
<span class="kw">use</span> <span class="ident">palette</span>::{<span class="ident">rgb::PackedArgb</span>, <span class="ident">cast</span>, <span class="ident">Srgba</span>};

<span class="kw">let</span> <span class="ident">raw</span> <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="number">0xFF7F0080u32</span>, <span class="number">0xFF60BBCC</span>];
<span class="kw">let</span> <span class="ident">colors</span> <span class="op">=</span> <span class="ident">cast::from_uint_slice</span>::<span class="op">&lt;</span><span class="ident">PackedArgb</span><span class="op">&gt;</span>(<span class="ident">raw</span>);

<span class="macro">assert_eq!</span>(<span class="ident">colors</span>.<span class="ident">len</span>(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(<span class="ident">Srgba::from</span>(<span class="ident">colors</span>[<span class="number">0</span>]), <span class="ident">Srgba::new</span>(<span class="number">0x7F</span>, <span class="number">0x00</span>, <span class="number">0x80</span>, <span class="number">0xFF</span>));
<span class="macro">assert_eq!</span>(<span class="ident">Srgba::from</span>(<span class="ident">colors</span>[<span class="number">1</span>]), <span class="ident">Srgba::new</span>(<span class="number">0x60</span>, <span class="number">0xBB</span>, <span class="number">0xCC</span>, <span class="number">0xFF</span>));</pre></div>
</div></details><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<table><tr class="module-item"><td><a class="struct" href="struct.BoxedSliceCastError.html" title="palette::cast::BoxedSliceCastError struct">BoxedSliceCastError</a></td><td class="docblock-short"><p>The error type returned when casting a boxed slice of components fails.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.Packed.html" title="palette::cast::Packed struct">Packed</a></td><td class="docblock-short"><p>A color packed into a compact format, such as an unsigned integer.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.SliceCastError.html" title="palette::cast::SliceCastError struct">SliceCastError</a></td><td class="docblock-short"><p>The error type returned when casting a slice of components fails.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.VecCastError.html" title="palette::cast::VecCastError struct">VecCastError</a></td><td class="docblock-short"><p>The error type returned when casting a <code>Vec</code> of components fails.</p>
</td></tr></table><h2 id="enums" class="section-header"><a href="#enums">Enums</a></h2>
<table><tr class="module-item"><td><a class="enum" href="enum.VecCastErrorKind.html" title="palette::cast::VecCastErrorKind enum">VecCastErrorKind</a></td><td class="docblock-short"><p>The type of error that is returned when casting a <code>Vec</code> of components.</p>
</td></tr></table><h2 id="traits" class="section-header"><a href="#traits">Traits</a></h2>
<table><tr class="module-item"><td><a class="trait" href="trait.ArrayCast.html" title="palette::cast::ArrayCast trait">ArrayCast</a></td><td class="docblock-short"><p>Marker trait for types that can be represented as a fixed size array.</p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.ComponentOrder.html" title="palette::cast::ComponentOrder trait">ComponentOrder</a></td><td class="docblock-short"><p>Packs and unpacks color types with some component order.</p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.UintCast.html" title="palette::cast::UintCast trait">UintCast</a></td><td class="docblock-short"><p>Marker trait for types that can be represented as an unsigned integer.</p>
</td></tr></table><h2 id="functions" class="section-header"><a href="#functions">Functions</a></h2>
<table><tr class="module-item"><td><a class="fn" href="fn.from_array.html" title="palette::cast::from_array fn">from_array</a></td><td class="docblock-short"><p>Cast from an array to a color type.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.from_array_box.html" title="palette::cast::from_array_box fn">from_array_box</a></td><td class="docblock-short"><p>Cast from a boxed array to a boxed color type.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.from_array_mut.html" title="palette::cast::from_array_mut fn">from_array_mut</a></td><td class="docblock-short"><p>Cast from a mutable array reference to a mutable color type reference.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.from_array_ref.html" title="palette::cast::from_array_ref fn">from_array_ref</a></td><td class="docblock-short"><p>Cast from an array reference to a color type reference.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.from_array_slice.html" title="palette::cast::from_array_slice fn">from_array_slice</a></td><td class="docblock-short"><p>Cast from a slice of arrays to a slice of colors.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.from_array_slice_box.html" title="palette::cast::from_array_slice_box fn">from_array_slice_box</a></td><td class="docblock-short"><p>Cast from a boxed slice of arrays to a boxed slice of colors.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.from_array_slice_mut.html" title="palette::cast::from_array_slice_mut fn">from_array_slice_mut</a></td><td class="docblock-short"><p>Cast from a mutable slice of arrays to a mutable slice of colors.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.from_array_vec.html" title="palette::cast::from_array_vec fn">from_array_vec</a></td><td class="docblock-short"><p>Cast from a <code>Vec</code> of arrays to a <code>Vec</code> of colors.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.from_component_slice.html" title="palette::cast::from_component_slice fn">from_component_slice</a></td><td class="docblock-short"><p>The same as <a href="fn.try_from_component_slice.html" title="try_from_component_slice"><code>try_from_component_slice</code></a> but panics on error.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.from_component_slice_box.html" title="palette::cast::from_component_slice_box fn">from_component_slice_box</a></td><td class="docblock-short"><p>The same as <a href="fn.try_from_component_slice_box.html" title="try_from_component_slice_box"><code>try_from_component_slice_box</code></a> but panics on error.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.from_component_slice_mut.html" title="palette::cast::from_component_slice_mut fn">from_component_slice_mut</a></td><td class="docblock-short"><p>The same as <a href="fn.try_from_component_slice_mut.html" title="try_from_component_slice_mut"><code>try_from_component_slice_mut</code></a> but panics on error.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.from_component_vec.html" title="palette::cast::from_component_vec fn">from_component_vec</a></td><td class="docblock-short"><p>The same as <a href="fn.try_from_component_vec.html" title="try_from_component_vec"><code>try_from_component_vec</code></a> but panics on error.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.from_uint.html" title="palette::cast::from_uint fn">from_uint</a></td><td class="docblock-short"><p>Cast from an unsigned integer to a color type.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.from_uint_mut.html" title="palette::cast::from_uint_mut fn">from_uint_mut</a></td><td class="docblock-short"><p>Cast from a mutable unsigned integer reference to a mutable color type reference.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.from_uint_ref.html" title="palette::cast::from_uint_ref fn">from_uint_ref</a></td><td class="docblock-short"><p>Cast from an unsigned integer reference to a color type reference.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.from_uint_slice.html" title="palette::cast::from_uint_slice fn">from_uint_slice</a></td><td class="docblock-short"><p>Cast from a slice of unsigned integers to a slice of colors.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.from_uint_slice_box.html" title="palette::cast::from_uint_slice_box fn">from_uint_slice_box</a></td><td class="docblock-short"><p>Cast from a boxed slice of unsigned integers to a boxed slice of colors.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.from_uint_slice_mut.html" title="palette::cast::from_uint_slice_mut fn">from_uint_slice_mut</a></td><td class="docblock-short"><p>Cast from a mutable slice of unsigned integers to a mutable slice of colors.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.from_uint_vec.html" title="palette::cast::from_uint_vec fn">from_uint_vec</a></td><td class="docblock-short"><p>Cast from a <code>Vec</code> of unsigned integers to a <code>Vec</code> of colors.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.into_array.html" title="palette::cast::into_array fn">into_array</a></td><td class="docblock-short"><p>Cast from a color type to an array.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.into_array_box.html" title="palette::cast::into_array_box fn">into_array_box</a></td><td class="docblock-short"><p>Cast from a boxed color type to a boxed array.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.into_array_mut.html" title="palette::cast::into_array_mut fn">into_array_mut</a></td><td class="docblock-short"><p>Cast from a mutable color type reference to a mutable array reference.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.into_array_ref.html" title="palette::cast::into_array_ref fn">into_array_ref</a></td><td class="docblock-short"><p>Cast from a color type reference to an array reference.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.into_array_slice.html" title="palette::cast::into_array_slice fn">into_array_slice</a></td><td class="docblock-short"><p>Cast from a slice of colors to a slice of arrays.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.into_array_slice_box.html" title="palette::cast::into_array_slice_box fn">into_array_slice_box</a></td><td class="docblock-short"><p>Cast from a boxed slice of colors to a boxed slice of arrays.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.into_array_slice_mut.html" title="palette::cast::into_array_slice_mut fn">into_array_slice_mut</a></td><td class="docblock-short"><p>Cast from a mutable slice of colors to a mutable slice of arrays.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.into_array_vec.html" title="palette::cast::into_array_vec fn">into_array_vec</a></td><td class="docblock-short"><p>Cast from a <code>Vec</code> of colors to a <code>Vec</code> of arrays.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.into_component_slice.html" title="palette::cast::into_component_slice fn">into_component_slice</a></td><td class="docblock-short"><p>Cast from a slice of colors to a slice of color components.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.into_component_slice_box.html" title="palette::cast::into_component_slice_box fn">into_component_slice_box</a></td><td class="docblock-short"><p>Cast from a boxed slice of colors to a boxed slice of color components.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.into_component_slice_mut.html" title="palette::cast::into_component_slice_mut fn">into_component_slice_mut</a></td><td class="docblock-short"><p>Cast from a slice of colors to a slice of color components.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.into_component_vec.html" title="palette::cast::into_component_vec fn">into_component_vec</a></td><td class="docblock-short"><p>Cast from a <code>Vec</code> of colors to a <code>Vec</code> of color components.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.into_uint.html" title="palette::cast::into_uint fn">into_uint</a></td><td class="docblock-short"><p>Cast from a color type to an unsigned integer.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.into_uint_mut.html" title="palette::cast::into_uint_mut fn">into_uint_mut</a></td><td class="docblock-short"><p>Cast from a mutable color type reference to a mutable unsigned integer reference.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.into_uint_ref.html" title="palette::cast::into_uint_ref fn">into_uint_ref</a></td><td class="docblock-short"><p>Cast from a color type reference to an unsigned integer reference.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.into_uint_slice.html" title="palette::cast::into_uint_slice fn">into_uint_slice</a></td><td class="docblock-short"><p>Cast from a slice of colors to a slice of unsigned integers.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.into_uint_slice_box.html" title="palette::cast::into_uint_slice_box fn">into_uint_slice_box</a></td><td class="docblock-short"><p>Cast from a boxed slice of colors to a boxed slice of unsigned integers.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.into_uint_slice_mut.html" title="palette::cast::into_uint_slice_mut fn">into_uint_slice_mut</a></td><td class="docblock-short"><p>Cast from a mutable slice of colors to a mutable slice of unsigned integers.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.into_uint_vec.html" title="palette::cast::into_uint_vec fn">into_uint_vec</a></td><td class="docblock-short"><p>Cast from a <code>Vec</code> of colors to a <code>Vec</code> of unsigned integers.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.try_from_component_slice.html" title="palette::cast::try_from_component_slice fn">try_from_component_slice</a></td><td class="docblock-short"><p>Cast from a slice of color components to a slice of colors.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.try_from_component_slice_box.html" title="palette::cast::try_from_component_slice_box fn">try_from_component_slice_box</a></td><td class="docblock-short"><p>Cast from a boxed slice of color components to a boxed slice of colors.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.try_from_component_slice_mut.html" title="palette::cast::try_from_component_slice_mut fn">try_from_component_slice_mut</a></td><td class="docblock-short"><p>Cast from a mutable slice of color components to a slice of colors.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.try_from_component_vec.html" title="palette::cast::try_from_component_vec fn">try_from_component_vec</a></td><td class="docblock-short"><p>Cast from a <code>Vec</code> of color components to a <code>Vec</code> of colors.</p>
</td></tr></table><h2 id="derives" class="section-header"><a href="#derives">Derive Macros</a></h2>
<table><tr class="module-item"><td><a class="derive" href="derive.ArrayCast.html" title="palette::cast::ArrayCast derive">ArrayCast</a></td><td class="docblock-short"></td></tr></table></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="palette" data-search-index-js="../../search-index.js" data-search-js="../../search.js"></div><script src="../../main.js"></script></body></html>