<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Traits for converting between color spaces."><title>palette::convert - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-84e720fa.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="palette" data-themes="" data-resource-suffix="" data-rustdoc-version="1.89.0 (29483883e 2025-08-04)" data-channel="1.89.0" data-search-js="search-92309212.js" data-settings-js="settings-5514c975.js" ><script src="../../static.files/storage-4e99c027.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-fd3af306.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../palette/index.html">palette</a><span class="version">0.7.6</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module convert</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#in-place-conversion" title="In-place Conversion">In-place Conversion</a></li><li><a href="#reusing-intermediate-data" title="Reusing Intermediate Data">Reusing Intermediate Data</a></li><li><a href="#deriving-fromcolorunclamped" title="Deriving `FromColorUnclamped`">Deriving <code>FromColorUnclamped</code></a><ul><li><a href="#configuration-attributes" title="Configuration Attributes">Configuration Attributes</a></li><li><a href="#examples" title="Examples">Examples</a></li></ul></li></ul><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#derives" title="Derive Macros">Derive Macros</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate palette</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">palette</a></div><h1>Module <span>convert</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/palette/convert.rs.html#1-946">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Traits for converting between color spaces.</p>
<p>Each color space type, such as <a href="../rgb/struct.Rgb.html" title="struct palette::rgb::Rgb"><code>Rgb</code></a> and
<a href="../struct.Hsl.html" title="struct palette::Hsl"><code>Hsl</code></a>, implement a number of conversion traits:</p>
<ul>
<li><a href="trait.FromColor.html" title="trait palette::convert::FromColor"><code>FromColor</code></a> - Similar to <a href="https://doc.rust-lang.org/1.89.0/core/convert/trait.From.html" title="trait core::convert::From"><code>From</code></a>, converts from another color space.</li>
<li><a href="trait.IntoColor.html" title="trait palette::convert::IntoColor"><code>IntoColor</code></a> - Similar to <a href="https://doc.rust-lang.org/1.89.0/core/convert/trait.Into.html" title="trait core::convert::Into"><code>Into</code></a>, converts into another color space.</li>
<li><a href="trait.FromColorUnclamped.html" title="trait palette::convert::FromColorUnclamped"><code>FromColorUnclamped</code></a> - The same as <a href="trait.FromColor.html" title="trait palette::convert::FromColor"><code>FromColor</code></a>, but the resulting
values may be outside the typical bounds.</li>
<li><a href="trait.IntoColorUnclamped.html" title="trait palette::convert::IntoColorUnclamped"><code>IntoColorUnclamped</code></a> - The same as <a href="trait.IntoColor.html" title="trait palette::convert::IntoColor"><code>IntoColor</code></a>, but the resulting
values may be outside the typical bounds.</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>palette::{FromColor, IntoColor, Srgb, Hsl};

<span class="kw">let </span>rgb = Srgb::new(<span class="number">0.3f32</span>, <span class="number">0.8</span>, <span class="number">0.1</span>);

<span class="kw">let </span>hsl1: Hsl = rgb.into_color();
<span class="kw">let </span>hsl2 = Hsl::from_color(rgb);</code></pre></div>
<p>Most of the color space types can be converted directly to each other, with
these traits. If you look at the implemented traits for any color type, you
will see a substantial list of <code>FromColorUnclamped</code> implementations. There
are, however, exceptions and restrictions in some cases:</p>
<ul>
<li><strong>It’s not always possible to change the component type while
converting.</strong> This can only be enabled in specific cases, to allow type
inference to work. The input and output component types need to be the
same in the general case.</li>
<li><strong>It’s not always possible to change meta types while converting.</strong> Meta
types are the additional input types on colors, such as white point or RGB
standard. Similar to component types, these are generally restricted to
help type inference.</li>
<li><strong>Some color spaces want specific component types.</strong> For example,
<a href="../struct.Xyz.html" title="struct palette::Xyz"><code>Xyz</code></a> and many other color spaces require real-ish numbers
(<code>f32</code>, <code>f64</code>, etc.).</li>
<li><strong>Some color spaces want specific meta types.</strong> For example,
<a href="../struct.Oklab.html" title="struct palette::Oklab"><code>Oklab</code></a> requires the white point to be
<a href="../white_point/struct.D65.html" title="struct palette::white_point::D65"><code>D65</code></a>.</li>
</ul>
<p>These limitations are usually the reason for why the compiler gives an error
when calling <code>into_color</code>, <code>from_color</code>, or the corresponding unclamped
methods. They are possible to work around by splitting the conversion into
multiple steps.</p>
<h2 id="in-place-conversion"><a class="doc-anchor" href="#in-place-conversion">§</a>In-place Conversion</h2>
<p>It’s possible for some color spaces to be converted in-place, meaning the
destination color will use the memory space of the source color. The
requirement for this is that the source and destination color types have the
same memory layout. That is, the same component types and the same number of
components. This is verified by the <a href="../cast/trait.ArrayCast.html" title="trait palette::cast::ArrayCast"><code>ArrayCast</code></a>
trait.</p>
<p>In-place conversion is done with the <a href="trait.FromColorMut.html" title="trait palette::convert::FromColorMut"><code>FromColorMut</code></a> and <a href="trait.IntoColorMut.html" title="trait palette::convert::IntoColorMut"><code>IntoColorMut</code></a>
traits, as well as their unclamped counterparts, <a href="trait.FromColorUnclampedMut.html" title="trait palette::convert::FromColorUnclampedMut"><code>FromColorUnclampedMut</code></a>
and <a href="trait.IntoColorUnclampedMut.html" title="trait palette::convert::IntoColorUnclampedMut"><code>IntoColorUnclampedMut</code></a>. They work for both single colors and slices
of colors.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>palette::{convert::FromColorMut, Srgb, Hsl, Hwb};

<span class="kw">let </span><span class="kw-2">mut </span>rgb_colors: Vec&lt;Srgb&lt;f32&gt;&gt; = <span class="macro">vec!</span>[<span class="comment">/* ... */</span>];

{
    <span class="comment">// Creates a scope guard that prevents `rgb_colors` from being modified as RGB.
    </span><span class="kw">let </span>hsl_colors = &lt;[Hsl]&gt;::from_color_mut(<span class="kw-2">&amp;mut </span>rgb_colors);

    <span class="comment">// The converted colors can be converted again, without keeping the previous guard around.
    </span><span class="kw">let </span>hwb_colors = hsl_colors.then_into_color_mut::&lt;[Hwb]&gt;();

    <span class="comment">// The colors are automatically converted back to RGB at the end of the scope.
    // The use of `then_into_color_mut` above makes this conversion a single HWB -&gt; RGB step,
    // instead of HWB -&gt; HSL -&gt; RGB, since it consumed the HSL guard.
</span>}</code></pre></div>
<h2 id="reusing-intermediate-data"><a class="doc-anchor" href="#reusing-intermediate-data">§</a>Reusing Intermediate Data</h2>
<p>Some conversions produce intermediate data that is the same for all values.
For example, conversion between <a href="../rgb/struct.Rgb.html" title="struct palette::rgb::Rgb"><code>Rgb</code></a> and
<a href="../struct.Xyz.html" title="struct palette::Xyz"><code>Xyz</code></a> uses a <a href="struct.Matrix3.html" title="struct palette::convert::Matrix3"><code>Matrix3</code></a>, while
<a href="../cam16/struct.Cam16.html" title="struct palette::cam16::Cam16"><code>Cam16</code></a> uses a set of viewing condition as
<a href="../cam16/struct.BakedParameters.html" title="struct palette::cam16::BakedParameters"><code>BakedParameters</code></a>. These values can be used
as “converters” via the <a href="trait.Convert.html" title="trait palette::convert::Convert"><code>Convert</code></a> and <a href="trait.ConvertOnce.html" title="trait palette::convert::ConvertOnce"><code>ConvertOnce</code></a> traits.</p>
<p><strong>Remember:</strong> As with anything related to optimization, the performance
difference may vary, depending on the compiler’s ability to detect and
optimize the repeated work on its own.</p>
<p>It’s sometimes possible to save some computation time by explicitly caching
and reusing these intermediate values:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>palette::{
    Srgb, Xyz, FromColor,
    cam16::{Cam16, Parameters},
    convert::Convert,
};

<span class="comment">// Parameters only need to "bake" once per set of viewing conditions:
</span><span class="kw">let </span>parameters = Parameters::default_static_wp(<span class="number">40.0</span>).bake();

<span class="kw">let </span>pixels: <span class="kw-2">&amp;</span>[Srgb&lt;u8&gt;] = palette::cast::from_component_slice(<span class="kw-2">&amp;</span>image_data);
<span class="kw">for </span><span class="kw-2">&amp;</span>color <span class="kw">in </span>pixels {
    <span class="kw">let </span>input = Xyz::from_color(color.into_linear());
    <span class="kw">let </span>cam16: Cam16&lt;f32&gt; = parameters.convert(input);

    <span class="comment">// ...
</span>}</code></pre></div>
<p>It may also be possible to combine multiple matrix steps into a single
matrix, instead of applying them one-by-one:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>palette::{
    Srgb, Xyz, lms::BradfordLms,
    convert::Convert,
    white_point::D65,
};

<span class="comment">// While each matrix may be a compile time constant, the compiler may not
// combine them into a single matrix by itself:
</span><span class="kw">let </span>matrix = Xyz::matrix_from_rgb()
    .then(BradfordLms::&lt;D65, f32&gt;::matrix_from_xyz());

<span class="kw">let </span>pixels: <span class="kw-2">&amp;</span>[Srgb&lt;u8&gt;] = palette::cast::from_component_slice(<span class="kw-2">&amp;</span>image_data);
<span class="kw">for </span><span class="kw-2">&amp;</span>color <span class="kw">in </span>pixels {
    <span class="kw">let </span>lms = matrix.convert(color.into_linear());

    <span class="comment">// ...
</span>}</code></pre></div>
<h2 id="deriving-fromcolorunclamped"><a class="doc-anchor" href="#deriving-fromcolorunclamped">§</a>Deriving <code>FromColorUnclamped</code></h2>
<p><code>FromColorUnclamped</code> can be derived in a mostly automatic way. The other
traits are blanket implemented based on it. The default minimum requirement
is to implement <code>FromColorUnclamped&lt;Xyz&gt;</code>, but it can also be customized to
make use of generics and have other manual implementations.</p>
<p>It is also recommended to derive or implement
<a href="../trait.WithAlpha.html" title="trait palette::WithAlpha"><code>WithAlpha</code></a>, to be able to convert between all <code>Alpha</code>
wrapped color types.</p>
<h3 id="configuration-attributes"><a class="doc-anchor" href="#configuration-attributes">§</a>Configuration Attributes</h3>
<p>The derives can be configured using one or more <code>#[palette(...)]</code>
attributes. They can be attached to either the item itself, or to the
fields.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(FromColorUnclamped)]
#[palette(
    component = <span class="string">"T"</span>,
    rgb_standard = <span class="string">"S"</span>,
)]
#[repr(C)]
</span><span class="kw">struct </span>ExampleType&lt;S, T&gt; {
    <span class="comment">// ...
    </span><span class="attr">#[palette(alpha)]
    </span>alpha: T,
    standard: std::marker::PhantomData&lt;S&gt;,
}
</code></pre></div>
<h4 id="item-attributes"><a class="doc-anchor" href="#item-attributes">§</a>Item Attributes</h4>
<ul>
<li>
<p><code>skip_derives(Luma, Rgb)</code>: No conversion derives will be implemented for
these colors. They are instead to be implemented manually, and serve as
the basis for the automatic implementations.</p>
</li>
<li>
<p><code>white_point = "some::white_point::Type"</code>: Sets the white point type that
should be used when deriving. The default is <code>D65</code>, but it may be any
other type, including type parameters.</p>
</li>
<li>
<p><code>component = "some::component::Type"</code>: Sets the color component type that
should be used when deriving. The default is <code>f32</code>, but it may be any
other type, including type parameters.</p>
</li>
<li>
<p><code>rgb_standard = "some::rgb_standard::Type"</code>: Sets the RGB standard type
that should be used when deriving. The default is to either use <code>Srgb</code> or
a best effort to convert between standards, but sometimes it has to be set
to a specific type. This also accepts type parameters.</p>
</li>
<li>
<p><code>luma_standard = "some::rgb_standard::Type"</code>: Sets the Luma standard type
that should be used when deriving, similar to <code>rgb_standard</code>.</p>
</li>
</ul>
<h4 id="field-attributes"><a class="doc-anchor" href="#field-attributes">§</a>Field Attributes</h4>
<ul>
<li><code>alpha</code>: Specifies field as the color’s transparency value.</li>
</ul>
<h3 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h3>
<p>Minimum requirements implementation:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>palette::convert::FromColorUnclamped;
<span class="kw">use </span>palette::{Srgb, Xyz, IntoColor};

<span class="doccomment">/// A custom version of Xyz that stores integer values from 0 to 100.
</span><span class="attr">#[derive(PartialEq, Debug, FromColorUnclamped)]
</span><span class="kw">struct </span>Xyz100 {
    x: u8,
    y: u8,
    z: u8,
}

<span class="comment">// We have to implement at least one "manual" conversion. The default
// is to and from `Xyz`, but it can be customized with `skip_derives(...)`.
</span><span class="kw">impl </span>FromColorUnclamped&lt;Xyz&gt; <span class="kw">for </span>Xyz100 {
    <span class="kw">fn </span>from_color_unclamped(color: Xyz) -&gt; Xyz100 {
        Xyz100 {
            x: (color.x * <span class="number">100.0</span>) <span class="kw">as </span>u8,
            y: (color.y * <span class="number">100.0</span>) <span class="kw">as </span>u8,
            z: (color.z * <span class="number">100.0</span>) <span class="kw">as </span>u8,
        }
    }
}

<span class="kw">impl </span>FromColorUnclamped&lt;Xyz100&gt; <span class="kw">for </span>Xyz {
    <span class="kw">fn </span>from_color_unclamped(color: Xyz100) -&gt; Xyz {
        Xyz::new(
            color.x <span class="kw">as </span>f32 / <span class="number">100.0</span>,
            color.y <span class="kw">as </span>f32 / <span class="number">100.0</span>,
            color.z <span class="kw">as </span>f32 / <span class="number">100.0</span>,
        )
    }
}

<span class="comment">// Start with an Xyz100 color.
</span><span class="kw">let </span>xyz = Xyz100 {
    x: <span class="number">59</span>,
    y: <span class="number">75</span>,
    z: <span class="number">42</span>,
};

<span class="comment">// Convert the color to sRGB.
</span><span class="kw">let </span>rgb: Srgb = xyz.into_color();

<span class="macro">assert_eq!</span>(rgb.into_format(), Srgb::new(<span class="number">196u8</span>, <span class="number">238</span>, <span class="number">154</span>));</code></pre></div>
<p>With generic components:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[macro_use]
</span><span class="kw">extern crate </span>approx;

<span class="kw">use </span>palette::cast::{ComponentsAs, ArrayCast};
<span class="kw">use </span>palette::rgb::{Rgb, RgbSpace, RgbStandard};
<span class="kw">use </span>palette::encoding::Linear;
<span class="kw">use </span>palette::white_point::D65;
<span class="kw">use </span>palette::convert::{FromColorUnclamped, IntoColorUnclamped};
<span class="kw">use </span>palette::{Hsv, Srgb, IntoColor};

<span class="doccomment">/// sRGB, but with a reversed memory layout.
</span><span class="attr">#[derive(Copy, Clone, ArrayCast, FromColorUnclamped)]
#[palette(
    skip_derives(Rgb),
    component = <span class="string">"T"</span>,
    rgb_standard = <span class="string">"palette::encoding::Srgb"
</span>)]
#[repr(C)] </span><span class="comment">// Makes sure the memory layout is as we want it.
</span><span class="kw">struct </span>Bgr&lt;T&gt; {
    blue: T,
    green: T,
    red: T,
}

<span class="comment">// It converts from and into any linear Rgb type that has the
// D65 white point, which is the default if we don't specify
// anything else with the `white_point` attribute argument.
</span><span class="kw">impl</span>&lt;S, T&gt; FromColorUnclamped&lt;Bgr&lt;T&gt;&gt; <span class="kw">for </span>Rgb&lt;S, T&gt;
<span class="kw">where
    </span>S: RgbStandard,
    S::Space: RgbSpace&lt;WhitePoint = D65&gt;,
    Srgb&lt;T&gt;: IntoColorUnclamped&lt;Rgb&lt;S, T&gt;&gt;,
{
    <span class="kw">fn </span>from_color_unclamped(color: Bgr&lt;T&gt;) -&gt; Rgb&lt;S, T&gt; {
        Srgb::new(color.red, color.green, color.blue)
            .into_color_unclamped()
    }
}

<span class="kw">impl</span>&lt;S, T&gt; FromColorUnclamped&lt;Rgb&lt;S, T&gt;&gt; <span class="kw">for </span>Bgr&lt;T&gt;
<span class="kw">where
    </span>S: RgbStandard,
    S::Space: RgbSpace&lt;WhitePoint = D65&gt;,
    Srgb&lt;T&gt;: FromColorUnclamped&lt;Rgb&lt;S, T&gt;&gt;,
{
    <span class="kw">fn </span>from_color_unclamped(color: Rgb&lt;S, T&gt;) -&gt; Bgr&lt;T&gt; {
        <span class="kw">let </span>color = Srgb::from_color_unclamped(color);
        Bgr {
            blue: color.blue,
            green: color.green,
            red: color.red,
        }
    }
}

<span class="kw">fn </span>main() {
    <span class="kw">let </span>buffer = <span class="macro">vec!</span>[
        <span class="number">0.0f64</span>,
        <span class="number">0.0</span>,
        <span class="number">0.0</span>,
        <span class="number">0.0</span>,
        <span class="number">0.5</span>,
        <span class="number">0.25</span>,
    ];
    <span class="kw">let </span>buffer: <span class="kw-2">&amp;</span>[Bgr&lt;<span class="kw">_</span>&gt;] = buffer.components_as();
    <span class="kw">let </span>hsv: Hsv&lt;<span class="kw">_</span>, f64&gt; = buffer[<span class="number">1</span>].into_color();

    <span class="macro">assert_relative_eq!</span>(hsv, Hsv::new(<span class="number">90.0</span>, <span class="number">1.0</span>, <span class="number">0.5</span>));
}</code></pre></div>
<p>With alpha component:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[macro_use]
</span><span class="kw">extern crate </span>approx;

<span class="kw">use </span>palette::{LinSrgba, Srgb, IntoColor, WithAlpha};
<span class="kw">use </span>palette::rgb::Rgb;
<span class="kw">use </span>palette::convert::{FromColorUnclamped, IntoColorUnclamped};

<span class="doccomment">/// CSS style sRGB.
</span><span class="attr">#[derive(PartialEq, Debug, FromColorUnclamped, WithAlpha)]
#[palette(
    skip_derives(Rgb),
    rgb_standard = <span class="string">"palette::encoding::Srgb"
</span>)]
</span><span class="kw">struct </span>CssRgb {
    red: u8,
    green: u8,
    blue: u8,
    <span class="attr">#[palette(alpha)]
    </span>alpha: f32,
}

<span class="comment">// We will write a conversion function for opaque RGB and
// `impl_default_conversions` will take care of preserving
// the transparency for us.
</span><span class="kw">impl</span>&lt;S&gt; FromColorUnclamped&lt;Rgb&lt;S, f32&gt;&gt; <span class="kw">for </span>CssRgb
<span class="kw">where
    </span>Srgb&lt;f32&gt;: FromColorUnclamped&lt;Rgb&lt;S, f32&gt;&gt;
{
    <span class="kw">fn </span>from_color_unclamped(color: Rgb&lt;S, f32&gt;) -&gt; CssRgb{
        <span class="kw">let </span>srgb = Srgb::from_color_unclamped(color)
            .into_format();

        CssRgb {
            red: srgb.red,
            green: srgb.green,
            blue: srgb.blue,
            alpha: <span class="number">1.0
        </span>}
    }
}

<span class="kw">impl</span>&lt;S&gt; FromColorUnclamped&lt;CssRgb&gt; <span class="kw">for </span>Rgb&lt;S, f32&gt;
<span class="kw">where
    </span>Srgb&lt;f32&gt;: IntoColorUnclamped&lt;Rgb&lt;S, f32&gt;&gt;
{
    <span class="kw">fn </span>from_color_unclamped(color: CssRgb) -&gt; Rgb&lt;S, f32&gt;{
        Srgb::new(color.red, color.green, color.blue)
            .into_format()
            .into_color_unclamped()
    }
}

<span class="kw">fn </span>main() {
    <span class="kw">let </span>css_color = CssRgb {
        red: <span class="number">187</span>,
        green: <span class="number">0</span>,
        blue: <span class="number">255</span>,
        alpha: <span class="number">0.3</span>,
    };
    <span class="kw">let </span>color: LinSrgba = css_color.into_color();

    <span class="macro">assert_relative_eq!</span>(color, LinSrgba::new(<span class="number">0.496933</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.3</span>), epsilon = <span class="number">0.000001</span>);
}</code></pre></div>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.FromColorMutGuard.html" title="struct palette::convert::FromColorMutGuard">From<wbr>Color<wbr>MutGuard</a></dt><dd>A scope guard that restores the guarded colors to their original type when
dropped.</dd><dt><a class="struct" href="struct.FromColorUnclampedMutGuard.html" title="struct palette::convert::FromColorUnclampedMutGuard">From<wbr>Color<wbr>Unclamped<wbr>MutGuard</a></dt><dd>A scope guard that restores the guarded colors to their original type,
without clamping, when dropped.</dd><dt><a class="struct" href="struct.Matrix3.html" title="struct palette::convert::Matrix3">Matrix3</a></dt><dd>A statically typed 3x3 conversion matrix.</dd><dt><a class="struct" href="struct.OutOfBounds.html" title="struct palette::convert::OutOfBounds">OutOf<wbr>Bounds</a></dt><dd>The error type for a color conversion that converted a color into a color
with invalid values.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.Convert.html" title="trait palette::convert::Convert">Convert</a></dt><dd>Represents types that can convert a value from one type to another.</dd><dt><a class="trait" href="trait.ConvertOnce.html" title="trait palette::convert::ConvertOnce">Convert<wbr>Once</a></dt><dd>Represents types that can convert a value from one type to another at least once.</dd><dt><a class="trait" href="trait.FromColor.html" title="trait palette::convert::FromColor">From<wbr>Color</a></dt><dd>A trait for converting one color from another, in a possibly lossy way.</dd><dt><a class="trait" href="trait.FromColorMut.html" title="trait palette::convert::FromColorMut">From<wbr>Color<wbr>Mut</a></dt><dd>Temporarily convert colors in place.</dd><dt><a class="trait" href="trait.FromColorUnclamped.html" title="trait palette::convert::FromColorUnclamped">From<wbr>Color<wbr>Unclamped</a></dt><dd>A trait for unchecked conversion of one color from another.</dd><dt><a class="trait" href="trait.FromColorUnclampedMut.html" title="trait palette::convert::FromColorUnclampedMut">From<wbr>Color<wbr>Unclamped<wbr>Mut</a></dt><dd>Temporarily convert colors in place, without clamping.</dd><dt><a class="trait" href="trait.IntoColor.html" title="trait palette::convert::IntoColor">Into<wbr>Color</a></dt><dd>A trait for converting a color into another, in a possibly lossy way.</dd><dt><a class="trait" href="trait.IntoColorMut.html" title="trait palette::convert::IntoColorMut">Into<wbr>Color<wbr>Mut</a></dt><dd>Temporarily convert colors in place. The <code>Into</code> counterpart to
<a href="trait.FromColorMut.html" title="trait palette::convert::FromColorMut"><code>FromColorMut</code></a>.</dd><dt><a class="trait" href="trait.IntoColorUnclamped.html" title="trait palette::convert::IntoColorUnclamped">Into<wbr>Color<wbr>Unclamped</a></dt><dd>A trait for unchecked conversion of a color into another.</dd><dt><a class="trait" href="trait.IntoColorUnclampedMut.html" title="trait palette::convert::IntoColorUnclampedMut">Into<wbr>Color<wbr>Unclamped<wbr>Mut</a></dt><dd>Temporarily convert colors in place. The <code>Into</code> counterpart to
<a href="trait.FromColorUnclampedMut.html" title="trait palette::convert::FromColorUnclampedMut"><code>FromColorUnclampedMut</code></a>.</dd><dt><a class="trait" href="trait.TryFromColor.html" title="trait palette::convert::TryFromColor">TryFrom<wbr>Color</a></dt><dd>A trait for fallible conversion of one color from another.</dd><dt><a class="trait" href="trait.TryIntoColor.html" title="trait palette::convert::TryIntoColor">TryInto<wbr>Color</a></dt><dd>A trait for fallible conversion of a color into another.</dd></dl><h2 id="derives" class="section-header">Derive Macros<a href="#derives" class="anchor">§</a></h2><dl class="item-table"><dt><a class="derive" href="derive.FromColorUnclamped.html" title="derive palette::convert::FromColorUnclamped">From<wbr>Color<wbr>Unclamped</a></dt></dl></section></div></main></body></html>